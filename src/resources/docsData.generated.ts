// AUTO-GENERATED by scripts/bundle-docs.ts — do not edit manually

export interface DocEntry { uri: string; title: string; content: string; }

export const docs: DocEntry[] = [
  {
    uri: "bind://docs/api/authentication",
    title: "Authentication",
    content: "# Authentication\n\nBind supports two authentication methods depending on the type of operation.\n\n## API Key Authentication\n\nFor programmatic, runtime operations — prove jobs, verification, shared proofs.\n\n```bash\ncurl -H \"X-API-Key: idbr_<keyId>_<secret>\" \\\n  https://api.bindprotocol.com/api/prove\n```\n\n### Creating API Keys\n\nCreate API keys in the dashboard under **Settings > API Keys**, or via the API:\n\n```bash\nPOST /api/orgs/:orgId/api-keys\nAuthorization: Bearer <jwt_token>\n```\n\n### Key Format\n\nKeys follow the format: `idbr_<keyId>_<secret>`\n\n- `idbr_` — prefix identifying Bind API keys\n- `<keyId>` — used for lookup and logging\n- `<secret>` — hashed and stored securely, never in plaintext\n\n### Revoking Keys\n\n```bash\nPOST /api/orgs/:orgId/api-keys/:keyId/revoke\nAuthorization: Bearer <jwt_token>\n```\n\n---\n\n## JWT Authentication\n\nFor dashboard and management operations — extractors, webhooks, organization settings, marketplace.\n\nJWT tokens are obtained by logging in with your email and password.\n\n```bash\ncurl -H \"Authorization: Bearer <id_token>\" \\\n  https://api.bindprotocol.com/api/auth/me\n```\n\n### Login\n\n```bash\nPOST /api/auth/login\nContent-Type: application/json\n\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"your-password\"\n}\n```\n\nResponse:\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"user\": { \"id\": \"...\", \"email\": \"...\", \"role\": \"org_manager\" },\n    \"org\": { \"id\": \"...\", \"name\": \"...\", \"tier\": \"pro\" },\n    \"session\": {\n      \"idToken\": \"...\",\n      \"accessToken\": \"...\",\n      \"refreshToken\": \"...\",\n      \"expiresIn\": 3600,\n      \"tokenType\": \"Bearer\"\n    }\n  }\n}\n```\n\n### Refreshing Tokens\n\n```bash\nPOST /api/auth/refresh\nContent-Type: application/json\n\n{\n  \"refreshToken\": \"your-refresh-token\"\n}\n```\n\n### Logout\n\n```bash\nPOST /api/auth/logout\nAuthorization: Bearer <token>\n```\n\n---\n\n## Which Auth Method to Use\n\n| Operation | Auth Method | Header |\n|-----------|------------|--------|\n| Submit prove job | API Key | `X-API-Key` |\n| Verify proofs | API Key | `X-API-Key` |\n| Issue credentials | API Key | `X-API-Key` |\n| Share proofs | API Key or JWT | `X-API-Key` or `Authorization` |\n| Manage extractors | JWT | `Authorization` |\n| Manage webhooks | JWT | `Authorization` |\n| Manage API keys | JWT | `Authorization` |\n| Marketplace browse/install | JWT | `Authorization` |\n| Organization settings | JWT | `Authorization` |\n\n**Rule of thumb:** Use API keys for runtime operations in your application code. Use JWT tokens for management operations (or use the dashboard).\n\n---\n\n## User Roles\n\n| Role | Permissions |\n|------|-------------|\n| `admin` | Full system access |\n| `org_manager` | Full org access, manage users and keys |\n| `org_user` | Read/write within org, no user management |",
  },
  {
    uri: "bind://docs/api/chains",
    title: "Chains",
    content: "# Chains\n\nGet blockchain network configuration for credential anchoring and verification.\n\n## List Chains\n\n```\nGET /api/chains\n```\n\n**Auth:** None (public)\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"chains\": [\n      {\n        \"id\": 11155111,\n        \"name\": \"Sepolia\",\n        \"rpcUrl\": \"https://rpc.sepolia.org\",\n        \"contracts\": {\n          \"credentialRegistry\": \"0x...\",\n          \"verifier\": \"0x...\"\n        },\n        \"blockExplorerUrl\": \"https://sepolia.etherscan.io\"\n      }\n    ]\n  }\n}\n```",
  },
  {
    uri: "bind://docs/api/credentials",
    title: "Credentials",
    content: "# Credentials\n\nIssue, verify, and revoke W3C Verifiable Credentials with optional on-chain anchoring.\n\n## List Credentials\n\n```\nGET /api/credentials\n```\n\n**Auth:** JWT\n\n### Query Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `limit` | number | 50 | Max 200 |\n| `offset` | number | 0 | Pagination offset |\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"credentials\": [\n      {\n        \"credentialHash\": \"0x...\",\n        \"transactionHash\": \"0x...\",\n        \"anchorChainId\": 11155111,\n        \"anchorChainName\": \"Sepolia\",\n        \"blockExplorerUrl\": \"https://sepolia.etherscan.io/tx/...\",\n        \"issuedAt\": \"2026-01-27T10:00:00Z\",\n        \"status\": \"active\",\n        \"revoked\": false\n      }\n    ],\n    \"pagination\": { \"total\": 1, \"limit\": 50, \"offset\": 0, \"count\": 1 }\n  }\n}\n```\n\n---\n\n## Issue Credential\n\n```\nPOST /api/credentials/issue\n```\n\n**Auth:** API Key | **Limits:** Counts toward monthly tier usage\n\n### Request\n\n```json\n{\n  \"credentialData\": {\n    \"subject\": \"did:example:123\",\n    \"riskBand\": \"LOW\",\n    \"score\": 85\n  },\n  \"expiry\": 1735689600,\n  \"anchorChainId\": 11155111,\n  \"verifyChainIds\": [421614],\n  \"enableZkVerify\": true,\n  \"proof\": { ... },\n  \"disclosedFields\": { \"riskBand\": \"LOW\" },\n  \"hiddenFields\": [\"score\"]\n}\n```\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `credentialData` | object | Yes | Credential fields |\n| `expiry` | number | No | Unix timestamp |\n| `anchorChainId` | number/string | Yes | Chain to issue on |\n| `verifyChainIds` | number[] | No | Additional chains to verify on |\n| `enableZkVerify` | boolean | No | Submit proof to zkVerify |\n| `disclosedFields` | object | No | Fields visible to verifiers |\n| `hiddenFields` | string[] | No | Fields hidden via ZK |\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"credentialHash\": \"0x...\",\n    \"credentialData\": { ... },\n    \"issuer\": \"0x...\",\n    \"anchorChain\": {\n      \"chainId\": 11155111,\n      \"chainName\": \"Sepolia\",\n      \"transactionHash\": \"0x...\",\n      \"blockNumber\": \"12345\"\n    },\n    \"verifications\": [ ... ],\n    \"zkVerify\": {\n      \"attestationId\": \"att_abc123\",\n      \"verified\": true,\n      \"transactionHash\": \"0x...\"\n    }\n  }\n}\n```\n\n---\n\n## Verify Credential\n\n```\nPOST /api/credentials/verify\n```\n\n**Auth:** API Key\n\nCross-chain credential verification.\n\n### Request\n\n```json\n{\n  \"credentialHash\": \"0xabc...\",\n  \"originChainId\": 11155111,\n  \"destChainId\": 421614,\n  \"checkZkVerify\": true\n}\n```\n\n---\n\n## Get Credential Status\n\n```\nGET /api/credentials/:credentialHash/status\n```\n\n**Auth:** API Key\n\n### Query Parameters\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `originChainId` | number/string | Chain where issued |\n| `destChainId` | number/string | Chain to check verification |\n\n---\n\n## Revoke Credential\n\n```\nPOST /api/credentials/:credentialHash/revoke\n```\n\n**Auth:** API Key\n\n### Request\n\n```json\n{\n  \"originChainId\": 11155111\n}\n```\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"credentialHash\": \"0x...\",\n    \"revocationHash\": \"0x...\",\n    \"originChain\": 11155111,\n    \"originChainName\": \"Sepolia\"\n  }\n}\n```",
  },
  {
    uri: "bind://docs/api/extractors",
    title: "Extractors",
    content: "# Extractors\n\nCreate and manage data extractors for zkTLS attestations.\n\n:::info\nExtractor endpoints require **JWT authentication**. You can also manage extractors through the dashboard UI.\n:::\n\n## Create Extractor\n\n```\nPOST /api/orgs/:orgId/extractors\n```\n\n**Auth:** JWT (org scope)\n\n### Request\n\n```json\n{\n  \"slug\": \"coinbase-user\",\n  \"name\": \"Coinbase User Profile\",\n  \"description\": \"Extracts user profile data from Coinbase API\",\n  \"domain\": \"api.coinbase.com\",\n  \"category\": \"finance\",\n  \"zktlsEnabled\": true\n}\n```\n\n### Response (201)\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"ext_abc123\",\n    \"slug\": \"coinbase-user\",\n    \"name\": \"Coinbase User Profile\",\n    \"visibility\": \"private\",\n    \"createdAt\": \"2026-01-27T10:00:00Z\"\n  }\n}\n```\n\n---\n\n## List Extractors\n\n```\nGET /api/orgs/:orgId/extractors\n```\n\n**Auth:** JWT (org scope)\n\n---\n\n## Get Extractor\n\n```\nGET /api/orgs/:orgId/extractors/:slug\n```\n\n**Auth:** JWT (org scope)\n\n---\n\n## Update Extractor\n\n```\nPUT /api/orgs/:orgId/extractors/:slug\n```\n\n**Auth:** JWT (org scope)\n\nPrivate extractors: all fields editable. Public extractors: only zkTLS settings.\n\n---\n\n## Delete Extractor\n\n```\nDELETE /api/orgs/:orgId/extractors/:slug\n```\n\n**Auth:** JWT (org scope)\n\nCascades to installations, sessions, and attestations.\n\n---\n\n## Publish Extractor\n\n```\nPOST /api/orgs/:orgId/extractors/:slug/publish\n```\n\n**Auth:** JWT (org scope)\n\n:::warning\nPublishing is permanent. Once public, the extractor is immutable.\n:::\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"ext_abc123\",\n    \"slug\": \"coinbase-user\",\n    \"visibility\": \"public\"\n  }\n}\n```\n\n---\n\n## Versions\n\n### Create Version\n\n```\nPOST /api/orgs/:orgId/extractors/:slug/versions\n```\n\n**Auth:** JWT (org scope)\n\n```json\n{\n  \"version\": \"1.1.0\",\n  \"extractionConfig\": { ... },\n  \"changelog\": \"Added verificationLevel claim\"\n}\n```\n\n### List Versions\n\n```\nGET /api/orgs/:orgId/extractors/:slug/versions\n```\n\n### Get Version\n\n```\nGET /api/orgs/:orgId/extractors/:slug/versions/:version\n```\n\n### Deprecate Version\n\n```\nPOST /api/orgs/:orgId/extractors/:slug/versions/:version/deprecate\n```\n\n```json\n{\n  \"message\": \"Use v1.1.0 instead\"\n}\n```",
  },
  {
    uri: "bind://docs/api/marketplace",
    title: "Marketplace",
    content: "# Marketplace\n\nBrowse, install, and manage public policies and extractors.\n\n:::info\nMarketplace endpoints require **JWT authentication**. You can also browse and install from the dashboard.\n:::\n\n## Browse Extractors\n\n```\nGET /api/marketplace/extractors\n```\n\n**Auth:** JWT\n\n### Query Parameters\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `category` | string | Filter by category |\n| `search` | string | Search by name |\n\n---\n\n## Get Public Extractor\n\n```\nGET /api/marketplace/extractors/:orgName/:slug\n```\n\n**Auth:** JWT\n\n---\n\n## Get Extractor Versions\n\n```\nGET /api/marketplace/extractors/:orgName/:slug/versions\n```\n\n**Auth:** JWT\n\n---\n\n## Install Extractor\n\n```\nPOST /api/marketplace/install\n```\n\n**Auth:** JWT\n\n### Request\n\n```json\n{\n  \"orgName\": \"bind\",\n  \"slug\": \"dimo-telematics\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### Response (201)\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"installationId\": \"inst_abc123\",\n    \"extractorSlug\": \"dimo-telematics\",\n    \"version\": \"1.0.0\"\n  }\n}\n```\n\n---\n\n## Manage Installed Extractors\n\n### List Installed\n\n```\nGET /api/orgs/:orgId/installed/extractors\n```\n\n### Check for Updates\n\n```\nGET /api/orgs/:orgId/installed/extractors/updates\n```\n\n### Upgrade\n\n```\nPUT /api/orgs/:orgId/installed/extractors/:installationId/upgrade\n```\n\n```json\n{ \"version\": \"1.1.0\" }\n```\n\n### Uninstall\n\n```\nDELETE /api/orgs/:orgId/installed/extractors/:installationId\n```\n\n---\n\n## Browse Policies\n\n```\nGET /api/marketplace/policies\n```\n\n**Auth:** JWT\n\n### Query Parameters\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `namespace` | string | Filter by namespace |\n| `search` | string | Search by name |\n\n---\n\n## Install Policy\n\n```\nPOST /api/marketplace/policies/install\n```\n\n**Auth:** JWT\n\n```json\n{\n  \"orgName\": \"bind\",\n  \"policyId\": \"bind.mobility.basicriskband\",\n  \"version\": \"0.1.0\"\n}\n```\n\n---\n\n## Manage Installed Policies\n\n| Method | Endpoint | Description |\n|--------|----------|-------------|\n| `GET` | `/api/orgs/:orgId/installed/policies` | List installed |\n| `GET` | `/api/orgs/:orgId/installed/policies/updates` | Check for updates |\n| `PUT` | `/api/orgs/:orgId/installed/policies/:id/upgrade` | Upgrade version |\n| `DELETE` | `/api/orgs/:orgId/installed/policies/:id` | Uninstall |",
  },
  {
    uri: "bind://docs/api/notifications",
    title: "Notifications",
    content: "# Notifications\n\nManage in-app notifications and delivery preferences.\n\n:::info\nAll notification endpoints require **JWT authentication**. You can also manage notifications in the dashboard via the bell icon and **Settings > Notifications**.\n:::\n\n## List Notifications\n\n```\nGET /api/notifications\n```\n\n**Auth:** JWT\n\n### Query Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `limit` | number | 20 | Max results per page (max 100) |\n| `cursor` | string | — | Cursor for pagination (ISO 8601 timestamp from `nextCursor`) |\n| `category` | string | — | Filter by category: `job_completion`, `job_failure`, `team_event`, `credential_event`, `shared_proof_event`, `system_alert` |\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"notifications\": [\n      {\n        \"id\": \"abc-123\",\n        \"type\": \"org\",\n        \"category\": \"job_completion\",\n        \"title\": \"Prove job completed\",\n        \"message\": \"Prove job for circuit \\\"age-check\\\" completed successfully.\",\n        \"metadata\": {\n          \"proveJobId\": \"job-456\",\n          \"actionUrl\": \"/prove-jobs\"\n        },\n        \"isRead\": false,\n        \"createdAt\": \"2026-02-11T10:30:00.000Z\"\n      }\n    ],\n    \"nextCursor\": \"2026-02-11T09:15:00.000Z\"\n  }\n}\n```\n\nUse `nextCursor` as the `cursor` query parameter to fetch the next page. When `nextCursor` is `null`, there are no more results.\n\n---\n\n## Get Unread Count\n\n```\nGET /api/notifications/unread-count\n```\n\n**Auth:** JWT\n\nReturns the number of unread notifications for the authenticated user, including org-wide notifications they haven't read.\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"count\": 5\n  }\n}\n```\n\n---\n\n## Mark Notification as Read\n\n```\nPATCH /api/notifications/:id/read\n```\n\n**Auth:** JWT\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"message\": \"Notification marked as read\"\n  }\n}\n```\n\n---\n\n## Mark All as Read\n\n```\nPATCH /api/notifications/read-all\n```\n\n**Auth:** JWT\n\nMarks all unread notifications (user-targeted and org-wide) as read for the authenticated user.\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"message\": \"All notifications marked as read\"\n  }\n}\n```\n\n---\n\n## Get Preferences\n\n```\nGET /api/notifications/preferences\n```\n\n**Auth:** JWT\n\nReturns the user's notification delivery preferences for each category and channel combination.\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": [\n    { \"category\": \"job_completion\", \"channel\": \"in_app\", \"enabled\": true },\n    { \"category\": \"job_completion\", \"channel\": \"email\", \"enabled\": true },\n    { \"category\": \"team_event\", \"channel\": \"in_app\", \"enabled\": true },\n    { \"category\": \"team_event\", \"channel\": \"email\", \"enabled\": false }\n  ]\n}\n```\n\n:::note\nIf a category/channel combination has no stored preference, it defaults to **enabled** for `in_app` and **enabled** for `email` on `job_completion`, `job_failure`, and `system_alert` categories. All other email categories default to **disabled**.\n:::\n\n---\n\n## Update Preferences\n\n```\nPUT /api/notifications/preferences\n```\n\n**Auth:** JWT\n\n### Request\n\n```json\n{\n  \"preferences\": [\n    { \"category\": \"job_completion\", \"channel\": \"email\", \"enabled\": false },\n    { \"category\": \"team_event\", \"channel\": \"in_app\", \"enabled\": true },\n    { \"category\": \"shared_proof_event\", \"channel\": \"email\", \"enabled\": true }\n  ]\n}\n```\n\n### Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `preferences` | array | Yes | Array of preference objects |\n| `preferences[].category` | string | Yes | One of: `job_completion`, `job_failure`, `team_event`, `credential_event`, `shared_proof_event`, `system_alert` |\n| `preferences[].channel` | string | Yes | `in_app` or `email` |\n| `preferences[].enabled` | boolean | Yes | Whether this category/channel is enabled |\n\n### Response\n\nReturns the full updated preference list (same format as `GET /api/notifications/preferences`).\n\n---\n\n## Notification Types\n\nNotifications are either **user-targeted** or **org-wide**:\n\n| Type | Visibility | Example |\n|------|-----------|---------|\n| `user` | Only the specific user | \"Your invite to Acme Corp was accepted\" |\n| `org` | All users in the organization | \"Prove job completed\", \"New shared proof received\" |\n\nOrg-wide notifications have independent read status per user — marking one as read only affects your view.\n\n---\n\n## Categories Reference\n\n| Category | Description | Typical Trigger |\n|----------|-------------|-----------------|\n| `job_completion` | Prove or compile jobs that succeed | Prove job completes, circuit compiles |\n| `job_failure` | Prove or compile jobs that fail | Prove job fails, circuit compilation fails |\n| `team_event` | Team membership changes | New member joins via invite |\n| `credential_event` | Credential lifecycle events | Credential issued, verified, or revoked |\n| `shared_proof_event` | Proof sharing between orgs | Another org shares a proof with you |\n| `system_alert` | Platform warnings and limits | Usage at 80%, 100%, or 120% of monthly cap |",
  },
  {
    uri: "bind://docs/api/oauth",
    title: "OAuth",
    content: "# OAuth\n\nConfigure OAuth providers for credential issuance flows and zkTLS authentication.\n\n:::info\nProvider configuration endpoints require **JWT authentication**. The `POST /api/oauth/initiate` endpoint uses **API Key** auth for runtime use.\n:::\n\n## List Provider Configs\n\n```\nGET /api/oauth/configs\n```\n\n**Auth:** JWT\n\nReturns configured OAuth providers and suggested callback URLs.\n\n---\n\n## Configure Provider\n\n```\nPUT /api/oauth/configs/:provider\n```\n\n**Auth:** JWT\n\n### Request\n\n```json\n{\n  \"clientId\": \"your-client-id\",\n  \"clientSecret\": \"your-client-secret\",\n  \"authUrl\": \"https://provider.com/oauth/authorize\",\n  \"tokenUrl\": \"https://provider.com/oauth/token\",\n  \"userInfoUrl\": \"https://provider.com/userinfo\",\n  \"scopes\": [\"openid\", \"profile\"],\n  \"enabled\": true\n}\n```\n\n---\n\n## Enable/Disable Provider\n\n```\nPATCH /api/oauth/configs/:provider\n```\n\n**Auth:** JWT\n\n```json\n{ \"enabled\": false }\n```\n\n---\n\n## Initiate OAuth Flow\n\n```\nPOST /api/oauth/initiate\n```\n\n**Auth:** API Key\n\n### Request\n\n```json\n{\n  \"provider\": \"coinbase\",\n  \"holderDid\": \"did:example:123\",\n  \"credentialType\": \"identity\",\n  \"scopes\": [\"openid\", \"profile\"]\n}\n```\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"authorizationUrl\": \"https://coinbase.com/oauth/authorize?...\",\n    \"state\": \"random-state-string\",\n    \"expiresAt\": \"2026-01-27T10:05:00Z\"\n  }\n}\n```\n\nRedirect the user to `authorizationUrl`. After they authenticate, the callback processes the token exchange and issues a credential automatically.\n\n---\n\n## Check OAuth State\n\n```\nGET /api/oauth/states/:state\n```\n\n**Auth:** API Key\n\nPoll this endpoint to check if the OAuth flow has completed.\n\n---\n\n## Get Issued Credential\n\n```\nGET /api/oauth/issued/:credentialId\n```\n\n**Auth:** API Key\n\nReturns the credential issued via OAuth flow, including anchor chain details and revocation status.",
  },
  {
    uri: "bind://docs/api/organizations",
    title: "Organizations",
    content: "# Organizations\n\nManage API keys, signing keys, and organization settings.\n\n:::info\nOrganization management endpoints require **JWT authentication**. You can also manage these in the dashboard under **Settings**.\n:::\n\n## API Keys\n\n### Create API Key\n\n```\nPOST /api/orgs/:orgId/api-keys\n```\n\n**Auth:** JWT (org scope)\n\n### List API Keys\n\n```\nGET /api/orgs/:orgId/api-keys\n```\n\n**Auth:** JWT (org scope)\n\n### Get API Key\n\n```\nGET /api/orgs/:orgId/api-keys/:keyId\n```\n\n**Auth:** JWT (org scope)\n\n### Revoke API Key\n\n```\nPOST /api/orgs/:orgId/api-keys/:keyId/revoke\n```\n\n**Auth:** JWT (org scope)\n\n---\n\n## Signing Keys\n\nUsed for signing W3C Verifiable Credentials.\n\n### Create Signing Key\n\n```\nPOST /api/orgs/:orgId/signing-keys\n```\n\n**Auth:** JWT (org scope)\n\n```json\n{\n  \"alias\": \"production-key\",\n  \"algorithm\": \"ES256\",\n  \"isDefault\": true\n}\n```\n\n| Field | Type | Default | Description |\n|-------|------|---------|-------------|\n| `alias` | string | — | Key identifier (alphanumeric, hyphens, underscores) |\n| `algorithm` | string | `ES256` | `ES256` (P-256) or `ES256K` (secp256k1) |\n| `isDefault` | boolean | false | Use as default signing key |\n\n### Response (201)\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"sk_abc123\",\n    \"keyAlias\": \"production-key\",\n    \"algorithm\": \"ES256\",\n    \"status\": \"active\",\n    \"isDefault\": true,\n    \"publicKeyJwk\": { \"kty\": \"EC\", \"crv\": \"P-256\", \"x\": \"...\", \"y\": \"...\" }\n  }\n}\n```\n\n### List Signing Keys\n\n```\nGET /api/orgs/:orgId/signing-keys\n```\n\n### Revoke Signing Key\n\n```\nDELETE /api/orgs/:orgId/signing-keys/:alias\n```\n\n### Set Default Key\n\n```\nPATCH /api/orgs/:orgId/signing-keys/:alias\n```\n\n```json\n{ \"isDefault\": true }\n```\n\n---\n\n## JWKS Endpoint\n\nPublic endpoint for verifiers to fetch organization signing keys.\n\n```\nGET /api/orgs/:orgId/.well-known/jwks.json\n```\n\n**Auth:** None (public)\n\n### Response\n\n```json\n{\n  \"keys\": [\n    {\n      \"kty\": \"EC\",\n      \"crv\": \"P-256\",\n      \"x\": \"...\",\n      \"y\": \"...\",\n      \"kid\": \"production-key\",\n      \"use\": \"sig\"\n    }\n  ]\n}\n```\n\n---\n\n## Self-Hosted Witnesses\n\nManage self-hosted witnesses for your organization. Requires **Enterprise** tier.\n\n### Register Witness\n\n```\nPOST /api/orgs/:orgId/witnesses\n```\n\n**Auth:** JWT (org scope)\n\n```json\n{\n  \"witnessId\": \"acme:my-witness\",\n  \"name\": \"ACME Internal Witness\",\n  \"publicKey\": \"<ed25519-public-key>\",\n  \"allowedDomains\": [\"api.internal.acme.com\"],\n  \"description\": \"Internal API witness\",\n  \"endpoint\": \"https://witness.acme.com\"\n}\n```\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `witnessId` | string | Yes | Unique identifier for the witness |\n| `name` | string | Yes | Display name |\n| `publicKey` | string | Yes | Ed25519 public key |\n| `allowedDomains` | string[] | Yes | Domains this witness can attest (non-empty) |\n| `description` | string | No | Description |\n| `endpoint` | string | No | Witness service endpoint URL |\n\n### Response (201)\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"witnessId\": \"acme:my-witness\",\n    \"name\": \"ACME Internal Witness\",\n    \"type\": \"self_hosted\",\n    \"orgId\": \"org_abc123\"\n  }\n}\n```\n\n### List Witnesses\n\n```\nGET /api/orgs/:orgId/witnesses\n```\n\n**Auth:** JWT (org scope)\n\nReturns all self-hosted witnesses registered by the organization.\n\n---\n\n## Organization Info\n\n### Get Current Org\n\n```\nGET /api/auth/org\n```\n\n**Auth:** JWT\n\n### Update Org Settings\n\n```\nPATCH /api/auth/org\n```\n\n**Auth:** JWT\n\n```json\n{ \"discoverable\": true }\n```\n\n---\n\n## Current User\n\n### Get Profile\n\n```\nGET /api/auth/me\n```\n\n**Auth:** JWT\n\nReturns user info, role, and org details.",
  },
  {
    uri: "bind://docs/api/overview",
    title: "API Overview",
    content: "# API Reference\n\nBase URL: `https://api.bindprotocol.com`\n\n## Authentication\n\nBind supports two authentication methods:\n\n| Method | Header | Use Case |\n|--------|--------|----------|\n| **API Key** | `X-API-Key: idbr_<keyId>_<secret>` | Runtime operations (prove, verify, share) |\n| **JWT** | `Authorization: Bearer <token>` | Dashboard and management operations |\n\nSee [Authentication](/api/authentication) for details.\n\n## Response Format\n\nAll responses follow a consistent format:\n\n```json\n{\n  \"success\": true,\n  \"data\": { ... }\n}\n```\n\nError responses:\n\n```json\n{\n  \"success\": false,\n  \"error\": \"Error message\",\n  \"code\": \"ERROR_CODE\"\n}\n```\n\n## Pagination\n\nList endpoints support pagination via query parameters:\n\n| Parameter | Default | Max | Description |\n|-----------|---------|-----|-------------|\n| `limit` | 50 | 100 | Number of results per page |\n| `offset` | 0 | — | Number of results to skip |\n\nPaginated responses include:\n\n```json\n{\n  \"pagination\": {\n    \"limit\": 50,\n    \"offset\": 0,\n    \"count\": 50,\n    \"total\": 237\n  }\n}\n```\n\n## Rate Limits\n\nRate limits vary by tier. Contact us for enterprise limits.\n\n## Endpoints\n\n### Core\n| Endpoint | Description |\n|----------|-------------|\n| [Prove](/api/prove) | Submit and manage prove jobs |\n| [Verify](/api/verify) | Verify proofs |\n| [Policies](/api/policies) | Browse public policies |\n| [Credentials](/api/credentials) | Issue, verify, and revoke credentials |\n\n### Data\n| Endpoint | Description |\n|----------|-------------|\n| [zkTLS](/api/zktls) | Create sessions and manage attestations |\n| [Extractors](/api/extractors) | Manage data extractors |\n| [Marketplace](/api/marketplace) | Browse and install public resources |\n\n### Platform\n| Endpoint | Description |\n|----------|-------------|\n| [Shared Proofs](/api/shared-proofs) | Share proofs between organizations |\n| [Webhooks](/api/webhooks) | Manage webhook subscriptions |\n| [Organizations](/api/organizations) | API keys, signing keys, settings |\n| [Chains](/api/chains) | Blockchain network configuration |\n| [OAuth](/api/oauth) | OAuth provider integration |",
  },
  {
    uri: "bind://docs/api/policies",
    title: "Policies",
    content: "# Policies\n\nBrowse available policies. These endpoints are public and do not require authentication.\n\n## List Policies\n\n```\nGET /api/policies\n```\n\n**Auth:** None (public)\n\nReturns all system policies and public org policies.\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": [\n    {\n      \"policyId\": \"bind.mobility.basicriskband\",\n      \"title\": \"Basic Vehicle Asset Risk Band\",\n      \"description\": \"Evaluates vehicle risk based on mileage, data sufficiency, and driving behavior.\",\n      \"version\": \"0.1.0\",\n      \"public\": true\n    }\n  ]\n}\n```\n\n---\n\n## Get Policy\n\n```\nGET /api/policies/:policyId\n```\n\n**Auth:** None (public)\n\nReturns the public spec for a specific policy.\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"policyId\": \"bind.mobility.basicriskband\",\n    \"title\": \"Basic Vehicle Asset Risk Band\",\n    \"description\": \"Evaluates vehicle risk based on mileage, data sufficiency, and driving behavior.\",\n    \"version\": \"0.1.0\",\n    \"schema\": { ... },\n    \"rules\": [ ... ]\n  }\n}\n```\n\n:::note\nOnly the **public spec** is returned. Private evaluation logic is not exposed.\n:::",
  },
  {
    uri: "bind://docs/api/prove",
    title: "Prove",
    content: "# Prove\n\nSubmit prove jobs for zero-knowledge proof generation.\n\n## Submit Prove Job\n\n```\nPOST /api/prove\n```\n\n**Auth:** API Key | **Limits:** Counts toward monthly tier usage\n\n### Request\n\n```json\n{\n  \"circuitId\": \"bind.dimo.riskband.v0_1_0\",\n  \"inputs\": {\n    \"mileage_90d\": \"2500\",\n    \"data_points\": \"450\",\n    \"speed_max\": \"72\"\n  },\n  \"verificationMode\": \"zkverify\"\n}\n```\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `circuitId` | string | Yes | Policy/circuit identifier |\n| `inputs` | Record&lt;string, string&gt; | Yes | Circuit inputs as key-value pairs |\n| `verificationMode` | string | No | `zkverify` or `self_verify` (defaults to config) |\n\n### Response (201)\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"jobId\": \"job_abc123\",\n    \"status\": \"pending\",\n    \"circuitId\": \"bind.dimo.riskband.v0_1_0\",\n    \"verificationMode\": \"zkverify\",\n    \"createdAt\": \"2026-01-27T10:00:00Z\"\n  }\n}\n```\n\n---\n\n## Get Prove Job\n\n```\nGET /api/prove/:jobId\n```\n\n**Auth:** API Key\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"jobId\": \"job_abc123\",\n    \"status\": \"completed\",\n    \"circuitId\": \"bind.dimo.riskband.v0_1_0\",\n    \"verificationMode\": \"zkverify\",\n    \"createdAt\": \"2026-01-27T10:00:00Z\",\n    \"startedAt\": \"2026-01-27T10:00:05Z\",\n    \"completedAt\": \"2026-01-27T10:00:45Z\",\n    \"error\": null,\n    \"attestationId\": \"att_xyz789\",\n    \"zkVerifyTxHash\": \"0x...\",\n    \"downloadUrls\": {\n      \"proof\": \"https://...\",\n      \"vk\": \"https://...\",\n      \"publicInputs\": \"https://...\"\n    }\n  }\n}\n```\n\n### Job Statuses\n\n| Status | Description |\n|--------|-------------|\n| `pending` | Job queued, waiting for worker |\n| `processing` | Worker is generating the proof |\n| `completed` | Proof generated successfully |\n| `failed` | Proof generation failed (see `error`) |\n\n---\n\n## List Prove Jobs\n\n```\nGET /api/prove\n```\n\n**Auth:** API Key or JWT\n\n### Query Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `status` | string | — | Filter by status |\n| `limit` | number | 50 | Max 100 |\n| `offset` | number | 0 | Pagination offset |\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"jobs\": [\n      {\n        \"jobId\": \"job_abc123\",\n        \"status\": \"completed\",\n        \"circuitId\": \"bind.dimo.riskband.v0_1_0\",\n        \"createdAt\": \"2026-01-27T10:00:00Z\",\n        \"completedAt\": \"2026-01-27T10:00:45Z\"\n      }\n    ],\n    \"pagination\": {\n      \"limit\": 50,\n      \"offset\": 0,\n      \"count\": 1,\n      \"total\": 1\n    }\n  }\n}\n```",
  },
  {
    uri: "bind://docs/api/shared-proofs",
    title: "Shared Proofs",
    content: "# Shared Proofs\n\nShare completed proofs between organizations for verification.\n\n## Share a Proof\n\n```\nPOST /api/shared-proofs\n```\n\n**Auth:** API Key or JWT\n\n### Request\n\n```json\n{\n  \"proveJobId\": \"job_abc123\",\n  \"verifierOrgId\": \"org_verifier\",\n  \"expiresAt\": \"2026-04-01T00:00:00Z\",\n  \"note\": \"Q1 2026 risk assessment\"\n}\n```\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `proveJobId` | string | Yes | Completed prove job ID |\n| `verifierOrgId` | string | Yes | Organization to share with |\n| `expiresAt` | string | No | ISO 8601 expiration |\n| `note` | string | No | Context for the verifier |\n\n### Response (201)\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"sp_xyz789\",\n    \"proveJobId\": \"job_abc123\",\n    \"verifierOrgId\": \"org_verifier\",\n    \"expiresAt\": \"2026-04-01T00:00:00Z\",\n    \"note\": \"Q1 2026 risk assessment\",\n    \"createdAt\": \"2026-01-27T10:00:00Z\",\n    \"proveJob\": {\n      \"id\": \"job_abc123\",\n      \"status\": \"completed\",\n      \"circuitId\": \"bind.dimo.riskband.v0_1_0\"\n    }\n  }\n}\n```\n\n---\n\n## List Shared Proofs\n\n```\nGET /api/shared-proofs\n```\n\n**Auth:** API Key or JWT\n\n### Query Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `direction` | string | `outgoing` | `outgoing` or `incoming` |\n| `limit` | number | 50 | Max 100 |\n| `offset` | number | 0 | Pagination offset |\n| `includeExpired` | boolean | false | Include expired (incoming only) |\n| `includeRevoked` | boolean | false | Include revoked (incoming only) |\n| `includeDismissed` | boolean | false | Include dismissed (incoming only) |\n\n---\n\n## Get Shared Proof\n\n```\nGET /api/shared-proofs/:id\n```\n\n**Auth:** API Key or JWT\n\nReturns the shared proof with prove job details and policy spec (public fields only).\n\n---\n\n## Dismiss Shared Proof\n\n```\nPOST /api/shared-proofs/:id/dismiss\n```\n\n**Auth:** API Key or JWT\n\nOnly the **verifier** organization can dismiss. Removes it from their active view.\n\n---\n\n## Revoke Shared Proof\n\n```\nDELETE /api/shared-proofs/:id\n```\n\n**Auth:** API Key or JWT\n\nOnly the **sharing** organization can revoke. The verifier can no longer access the proof.",
  },
  {
    uri: "bind://docs/api/verify",
    title: "Verify",
    content: "# Verify\n\nVerify proofs from shared proofs or uploaded artifacts.\n\n## Verify Shared Proof\n\n```\nPOST /api/verify/shared/:sharedProofId\n```\n\n**Auth:** API Key | **Limits:** Counts toward monthly tier usage\n\n### Response (202)\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"jobId\": \"vfy_abc123\",\n    \"status\": \"pending\"\n  }\n}\n```\n\n---\n\n## Verify Uploaded Proof\n\n```\nPOST /api/verify/upload\n```\n\n**Auth:** API Key\n\nUpload proof artifacts directly for verification.\n\n### Request\n\n```json\n{\n  \"proof\": \"base64-encoded proof binary\",\n  \"vk\": \"base64-encoded verification key binary\",\n  \"numPublicInputs\": 1,\n  \"expectedPublicInputs\": [\"0x01\"]\n}\n```\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `proof` | string | Yes | Base64-encoded proof |\n| `vk` | string | Yes | Base64-encoded verification key |\n| `numPublicInputs` | number | No | Number of public inputs (1-100) |\n| `expectedPublicInputs` | string[] | No | Expected public input values (hex) |\n\n### Response (202)\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"jobId\": \"vfy_def456\",\n    \"status\": \"pending\"\n  }\n}\n```\n\n---\n\n## Get Verification Job\n\n```\nGET /api/verify/jobs/:jobId\n```\n\n**Auth:** API Key\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"status\": \"completed\",\n    \"isValid\": true,\n    \"verificationTimeMs\": 245,\n    \"verificationResultId\": \"vr_abc123\"\n  }\n}\n```\n\n---\n\n## Verification History\n\n```\nGET /api/verify/history\n```\n\n**Auth:** API Key\n\n### Query Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `limit` | number | 50 | Max 100 |\n| `offset` | number | 0 | Pagination offset |\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"results\": [\n      {\n        \"id\": \"vr_abc123\",\n        \"sharedProofId\": \"sp_xyz789\",\n        \"directUpload\": false,\n        \"proofHash\": \"0x...\",\n        \"isValid\": true,\n        \"verificationTimeMs\": 245,\n        \"createdAt\": \"2026-01-27T10:00:00Z\"\n      }\n    ],\n    \"pagination\": { \"limit\": 50, \"offset\": 0, \"count\": 1, \"total\": 1 }\n  }\n}\n```",
  },
  {
    uri: "bind://docs/api/webhooks",
    title: "Webhooks",
    content: "# Webhooks\n\nSubscribe to events and receive HTTP callbacks.\n\n:::info\nWebhook management endpoints require **JWT authentication**. You can also configure webhooks in the dashboard under **Settings > Webhooks**.\n:::\n\n## Create Webhook\n\n```\nPOST /api/webhooks\n```\n\n**Auth:** JWT\n\n### Request\n\n```json\n{\n  \"url\": \"https://your-app.com/webhooks/bind\",\n  \"events\": [\"credential.issued\", \"prove.completed\"],\n  \"name\": \"Production webhook\",\n  \"secret\": \"your-signing-secret\",\n  \"headers\": { \"X-Custom\": \"value\" }\n}\n```\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"wh_abc123\",\n    \"url\": \"https://your-app.com/webhooks/bind\",\n    \"events\": [\"credential.issued\", \"prove.completed\"],\n    \"secret\": \"your-signing-secret\"\n  }\n}\n```\n\n:::note\nThe `secret` is only returned on creation. Store it securely for signature verification.\n:::\n\n---\n\n## List Webhooks\n\n```\nGET /api/webhooks\n```\n\n**Auth:** JWT\n\n---\n\n## Get Webhook\n\n```\nGET /api/webhooks/:id\n```\n\n**Auth:** JWT\n\n---\n\n## Update Webhook\n\n```\nPUT /api/webhooks/:id\n```\n\n**Auth:** JWT\n\n---\n\n## Delete Webhook\n\n```\nDELETE /api/webhooks/:id\n```\n\n**Auth:** JWT\n\n---\n\n## Test Webhook\n\n```\nPOST /api/webhooks/:id/test\n```\n\n**Auth:** JWT\n\n```json\n{ \"event_type\": \"credential.issued\" }\n```\n\nReturns the HTTP status and response time from your endpoint.\n\n---\n\n## Rotate Secret\n\n```\nPOST /api/webhooks/:id/rotate-secret\n```\n\n**Auth:** JWT\n\nReturns the new secret.\n\n---\n\n## Delivery History\n\n```\nGET /api/webhooks/deliveries\n```\n\n**Auth:** JWT\n\n### Query Parameters\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `limit` | number | Default 50 |\n| `offset` | number | Default 0 |\n| `status` | string | `delivered`, `failed`, `pending` |\n| `event_type` | string | Filter by event type |\n| `webhook_id` | string | Filter by webhook |\n\n---\n\n## Statistics\n\n```\nGET /api/webhooks/stats\n```\n\n**Auth:** JWT\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `days` | number | 30 | Time window |\n| `webhook_id` | string | — | Filter by webhook |",
  },
  {
    uri: "bind://docs/api/zktls",
    title: "zkTLS",
    content: "# zkTLS\n\nCreate zkTLS sessions, manage attestations, and configure witnesses.\n\n## Create Session\n\n```\nPOST /api/zktls/sessions\n```\n\n**Auth:** JWT\n\n### Request\n\n```json\n{\n  \"extractor\": \"ext_abc123\",\n  \"callbackUrl\": \"https://your-app.com/callback\",\n  \"mode\": \"witness\",\n  \"witnessConfig\": {\n    \"mode\": \"single\"\n  }\n}\n```\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `extractor` | string | Yes | Extractor ID |\n| `callbackUrl` | string | Yes | URL called on completion |\n| `mode` | string | No | `witness` (default) or `extension` |\n| `maxCaptureAge` | number | No | Seconds (300-3600), for extension mode |\n| `witnessConfig.mode` | string | No | `single`, `threshold`, or `unanimous` |\n| `witnessConfig.threshold` | number | No | Required for threshold mode |\n| `witnessConfig.witnesses` | string[] | No | Witness IDs for multi-party |\n\n:::info Tier Requirements\n- **Multi-witness** modes (`threshold`, `unanimous`) require **Premium** tier or above.\n- **Self-hosted witnesses** in the `witnesses` array require **Enterprise** tier. If any referenced witness is self-hosted and the organization is not Enterprise, the request returns `403 TIER_PERMISSION_DENIED`.\n:::\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"sessionId\": \"sess_xyz789\",\n    \"authorizationUrl\": \"https://coinbase.com/oauth/authorize?...\",\n    \"expiresAt\": \"2026-01-27T10:05:00Z\"\n  }\n}\n```\n\n---\n\n## Get Session\n\n```\nGET /api/zktls/sessions/:id\n```\n\n**Auth:** JWT\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"sess_xyz789\",\n    \"status\": \"completed\",\n    \"extractorId\": \"ext_abc123\",\n    \"callbackUrl\": \"https://your-app.com/callback\",\n    \"mode\": \"witness\",\n    \"createdAt\": \"2026-01-27T10:00:00Z\"\n  }\n}\n```\n\n### Session Statuses\n\n| Status | Description |\n|--------|-------------|\n| `pending` | Session created, waiting for user |\n| `processing` | User authenticated, witness extracting |\n| `completed` | Attestation created |\n| `failed` | Session failed (see error) |\n\n---\n\n## List Extractors (zkTLS-enabled)\n\n```\nGET /api/zktls/extractors\n```\n\n**Auth:** API Key or JWT\n\nReturns extractors available for zkTLS sessions (public + org's private).\n\n---\n\n## List Attestations\n\n```\nGET /api/zktls/attestations\n```\n\n**Auth:** JWT\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": [\n    {\n      \"id\": \"att_abc123\",\n      \"claims\": { \"country\": \"US\", \"verified\": true },\n      \"witness\": \"bind-primary\",\n      \"signature\": \"base64...\",\n      \"expiresAt\": \"2026-01-27T10:05:00Z\",\n      \"createdAt\": \"2026-01-27T10:00:30Z\"\n    }\n  ]\n}\n```\n\n---\n\n## Get Attestation\n\n```\nGET /api/zktls/attestations/:id\n```\n\n**Auth:** JWT\n\n### Response\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"att_abc123\",\n    \"claims\": { \"country\": \"US\", \"verified\": true },\n    \"witness\": \"bind-primary\",\n    \"signature\": \"base64...\",\n    \"nonce\": \"random-nonce\",\n    \"url\": \"https://api.coinbase.com/v2/user\",\n    \"method\": \"GET\",\n    \"responseHash\": \"sha256:...\",\n    \"expiresAt\": \"2026-01-27T10:05:00Z\",\n    \"ctVerified\": true,\n    \"ctLogs\": [\"log1.ct.example.com\"]\n  }\n}\n```",
  },
  {
    uri: "bind://docs/concepts/credentials",
    title: "Credentials",
    content: "# Credentials\n\nA **credential** is the final output of the Bind attestation pipeline. Credentials are issued as W3C Verifiable Credentials (VC-JWT format) after a successful proof.\n\n## What's in a Credential\n\n- **Subject identifier** — What entity the credential is about\n- **Policy reference** — Which policy was evaluated\n- **Output claims** — The proven results (score, pass/fail, band)\n- **Validity period** — When the credential expires\n- **Cryptographic signature** — ECDSA P-256, independently verifiable\n\n## Credential Lifecycle\n\n```mermaid\nflowchart LR\n    A[Policy + Inputs] --> B[Proof Generation]\n    B --> C[Credential Issuance]\n    C --> D[\"On-chain Anchor\\n(optional)\"]\n    C --> E[\"W3C VC-JWT\\n(always)\"]\n```\n\n1. **Prove** — Submit inputs against a policy, ZK proof is generated\n2. **Issue** — Credential is signed and optionally anchored on-chain\n3. **Share** — Send credential to verifiers\n4. **Verify** — Verifiers check the cryptographic proof\n5. **Revoke** — Issuer can revoke if needed\n\n## On-Chain Anchoring\n\nCredentials can optionally be anchored on-chain for immutable proof of existence:\n\n- **EVM chains** — Credential hash stored in smart contract\n- **zkVerify** — ZK proof submitted for on-chain verification\n- **Cross-chain** — Verify on a different chain than where issued\n\n## Signing Keys\n\nOrganizations manage their own signing keys:\n\n- **ES256** (P-256 ECDSA) — Default, widely supported\n- **ES256K** (secp256k1 ECDSA) — Ethereum-compatible\n- Keys are securely managed by Bind\n- Public keys available via JWKS endpoint: `GET /api/orgs/:orgId/.well-known/jwks.json`\n\n## Verification\n\nVerifiers can validate credentials by:\n\n1. Fetching the issuer's public key from their JWKS endpoint\n2. Verifying the JWT signature\n3. Checking the credential hasn't been revoked\n4. Optionally checking the on-chain anchor\n\n## Next Steps\n\n- [API: Credentials](/api/credentials) — Issue, verify, and revoke credentials\n- [API: Shared Proofs](/api/shared-proofs) — Share proofs between organizations",
  },
  {
    uri: "bind://docs/concepts/extractors",
    title: "Extractors",
    content: "# Extractors\n\nAn **extractor** defines how to pull data from an external HTTPS API via zkTLS. Extractors are the bridge between real-world data sources and Bind policies.\n\n## How Extractors Work\n\n```mermaid\nflowchart TD\n    A[User Browser] --> B[zkTLS Witness]\n    B --> C[Target API]\n    C --> B\n    B --> D[\"Extractor Config\\n(domain, path, JSONPath)\"]\n    D --> E[Extracted Claims]\n    E --> F[Used by Policies]\n```\n\nThe extractor config tells the witness:\n- **Which endpoint** to intercept (domain + path pattern)\n- **What to extract** (JSONPath expressions)\n- **How to authenticate** (OAuth provider, if needed)\n\n## Extractor Structure\n\n```typescript\ninterface Extractor {\n  slug: string;              // Unique identifier (lowercase, hyphens)\n  domain: string;            // Target API domain (e.g., \"api.coinbase.com\")\n  pathPattern: string;       // URL path (supports wildcards)\n  method: \"GET\" | \"POST\";\n  claimsSchema: ClaimDefinition[];\n  zktlsEnabled: boolean;\n  requiresOAuth: boolean;\n  oauthProvider?: string;    // e.g., \"coinbase\", \"dimo\"\n  visibility: \"private\" | \"public\";\n}\n\ninterface ClaimDefinition {\n  name: string;              // Output claim name\n  path: string;              // JSONPath expression\n  type: \"string\" | \"number\" | \"boolean\";\n  required: boolean;\n}\n```\n\n## Example: Coinbase User\n\n```json\n{\n  \"slug\": \"coinbase-user\",\n  \"domain\": \"api.coinbase.com\",\n  \"pathPattern\": \"/v2/user\",\n  \"method\": \"GET\",\n  \"claimsSchema\": [\n    { \"name\": \"userId\", \"path\": \"$.data.id\", \"type\": \"string\", \"required\": true },\n    { \"name\": \"country\", \"path\": \"$.data.country.code\", \"type\": \"string\", \"required\": true },\n    { \"name\": \"verified\", \"path\": \"$.data.tiers.completed_description\", \"type\": \"string\", \"required\": false }\n  ],\n  \"zktlsEnabled\": true,\n  \"requiresOAuth\": true,\n  \"oauthProvider\": \"coinbase\",\n  \"visibility\": \"public\"\n}\n```\n\n## JSONPath Expressions\n\n| Expression | Extracts |\n|------------|----------|\n| `$.data.id` | `response.data.id` |\n| `$.items[0]` | First item in array |\n| `$.items[-1]` | Last item in array |\n| `$.items[*].currency` | All currencies from array |\n| `$.items[?(@.currency==\"USD\")].balance` | Conditional selection |\n\n## Versioning\n\nExtractors support semantic versioning:\n- **Patch** (1.0.0 -> 1.0.1): Bug fixes, no schema changes\n- **Minor** (1.0.0 -> 1.1.0): New optional claims added\n- **Major** (1.0.0 -> 2.0.0): Breaking changes (removed claims, type changes)\n\nVersions are immutable once created. Policies should pin to specific versions for production use.\n\n## Visibility\n\n| State | Who Can See | Mutable |\n|-------|-------------|---------|\n| **Private** | Creating org only | Yes |\n| **Public** | Everyone (marketplace) | No |\n\nPublishing is permanent. Once public, extractors are immutable.\n\n## Next Steps\n\n- [Extractor Authoring Guide](/guides/extractor-authoring) — Step-by-step creation guide\n- [Marketplace](/concepts/marketplace) — Browse and install public extractors",
  },
  {
    uri: "bind://docs/concepts/marketplace",
    title: "Marketplace",
    content: "# Marketplace\n\nThe Bind Marketplace is a public registry of reusable policies and extractors. Organizations can publish their work for others to use, and install public resources to avoid building from scratch.\n\n## How It Works\n\n### Publishing\n\nAny private policy or extractor can be published to the marketplace:\n\n```mermaid\nflowchart LR\n    A[\"Private\\n(mutable)\"] -->|publish| B[\"Public\\n(immutable, permanent)\"]\n```\n\nPublishing is a **one-way transition**. Once public, the resource is immutable to ensure reproducibility and trust.\n\n### Installing\n\nOrganizations install public policies and extractors:\n\n1. Browse the marketplace by category, domain, or search\n2. Install a specific version\n3. Use it in your own policies and workflows\n4. Upgrade to newer versions explicitly\n\nInstalled resources are pinned to a specific version and don't count against your org's tier limits.\n\n## Policies vs Extractors\n\n| | Policies | Extractors |\n|---|---|---|\n| **Purpose** | Define what to prove | Define where to get data |\n| **Example** | \"Safe Driver Verification\" | \"DIMO Telematics\" |\n| **Versioned** | Yes | Yes |\n| **Immutable when public** | Yes | Yes |\n\n## Discovery\n\n- Browse by category (finance, insurance, identity, etc.)\n- Search by name, domain, or tags\n- View version history and changelogs\n- Check installation counts\n\n## API Endpoints\n\n| Endpoint | Description |\n|----------|-------------|\n| `GET /api/marketplace/extractors` | Browse public extractors |\n| `GET /api/marketplace/policies` | Browse public policies |\n| `POST /api/marketplace/install` | Install an extractor |\n| `POST /api/marketplace/policies/install` | Install a policy |\n\nSee the full [Marketplace API Reference](/api/marketplace) for details.",
  },
  {
    uri: "bind://docs/concepts/organizations",
    title: "Organizations and Tiers",
    content: "# Organizations and Tiers\n\nEvery Bind account belongs to an **organization**. Your organization's tier determines what you can do on the platform — whether you're generating proofs, verifying credentials, or both.\n\n## Tiers\n\nBind offers five tiers, each designed for a different role in the attestation ecosystem.\n\n### Basic\n\nThe starting tier for teams exploring Bind. Basic organizations can submit prove jobs and share proofs — but cannot create policies, create extractors, or verify proofs. Ideal for prototyping with existing public policies.\n\n### Premium\n\nFull-featured access for production prover workloads. Premium unlocks policy creation, proof verification, multi-witness attestations, self-signed credentials, and significantly higher resource limits. Designed for teams running live integrations.\n\n### Scale\n\nHigh-volume production tier for organizations that need extractor authoring, higher policy limits, and greater throughput. Scale includes everything in Premium plus the ability to create and publish extractors with expanded resource and complexity limits.\n\n### Verifier\n\nA specialized tier for organizations that only need to receive and verify proofs. Verifier orgs cannot create policies, submit prove jobs, or share proofs — they consume credentials shared by prover organizations.\n\n### Enterprise\n\nUnlimited resources, self-hosted witnesses, SSO/SAML authentication, dedicated support, and SLA guarantees. Contact [sales@bindprotocol.com](mailto:sales@bindprotocol.com) for details.\n\n## Permissions by Tier\n\n| Capability | Basic | Premium | Scale | Verifier | Enterprise |\n|------------|-------|---------|-------|----------|------------|\n| Create policies | — | ✓ | ✓ | — | ✓ |\n| Create extractors | — | — | ✓ | — | ✓ |\n| Submit prove jobs | ✓ | ✓ | ✓ | — | ✓ |\n| Verify proofs | — | ✓ | ✓ | ✓ | ✓ |\n| Share proofs | ✓ | ✓ | ✓ | — | ✓ |\n| Multi-witness attestations | — | ✓ | ✓ | — | ✓ |\n| Self-sign credentials | — | ✓ | ✓ | — | ✓ |\n| Self-hosted witnesses | — | — | — | — | ✓ |\n| SSO/SAML authentication | — | — | — | — | ✓ |\n\n## Resource Limits\n\n| Resource | Basic | Premium | Scale | Verifier | Enterprise |\n|----------|-------|---------|-------|----------|------------|\n| API keys | 1 | Unlimited | Unlimited | 5 | Unlimited |\n| Signing keys | 0 | 5 | 10 | 1 | Unlimited |\n| Webhooks | 1 | Unlimited | Unlimited | 3 | Unlimited |\n| Users | 3 | Unlimited | Unlimited | 10 | Unlimited |\n| Policies | 0 | 100 | 500 | 0 | Unlimited |\n| Extractors | 0 | 0 | 50 | 0 | Unlimited |\n\n## Policy Complexity Limits\n\nTiers that can create policies are also subject to per-policy complexity limits. These are enforced when saving a policy via the API or dashboard.\n\n| Limit | Premium | Scale | Enterprise |\n|-------|---------|-------|------------|\n| Max inputs | 10 | 20 | Unlimited |\n| Max rules | 25 | 50 | Unlimited |\n| Max outputs | 5 | 10 | Unlimited |\n| Max expression depth | 5 | 10 | Unlimited |\n\n### Input Source Kind Restrictions\n\nNot all input source kinds are available on every tier. Basic-tier organizations are limited to simpler source types. Attempting to use a restricted source kind returns a `403` error with an upgrade message.\n\n| Source Kind | Description | Basic | Premium | Scale | Enterprise |\n|-------------|-------------|-------|---------|-------|------------|\n| `dimo` | DIMO telematics | ✓ | ✓ | ✓ | ✓ |\n| `api` | External API | ✓ | ✓ | ✓ | ✓ |\n| `static` | Static/direct value | ✓ | ✓ | ✓ | ✓ |\n| `composed` | Policy-as-input (composition) | — | ✓ | ✓ | ✓ |\n| `zktls` | zkTLS attestation | — | ✓ | ✓ | ✓ |\n\nIn the dashboard, restricted source kinds appear greyed out with a \"Premium required\" label in both the Visual Builder and Flow Composer.\n\n## Usage Limits\n\nEach tier includes monthly volume caps for metered operations such as proof generation, verification, and credential issuance. Usage resets at the start of each calendar month. You can view your current usage in the dashboard on the **Home** page or via `GET /api/tier/usage`.\n\n## Prover vs Verifier\n\nThe tier system reflects two fundamental roles in the Bind ecosystem:\n\n```mermaid\nflowchart LR\n    A[\"Prover Org\\n(Basic / Premium / Scale / Enterprise)\"] -->|shares proof| B[\"Verifier Org\\n(Verifier / Premium / Scale / Enterprise)\"]\n    B -->|verifies credential| C[Trust Established]\n```\n\n**Prover organizations** (Basic, Premium, Scale, Enterprise) submit prove jobs, generate zero-knowledge proofs from data, and share the resulting credentials with verifiers.\n\n**Verifier organizations** (Verifier, Premium, Scale, Enterprise) receive shared proofs and verify credential authenticity using the issuer's public signing keys via [JWKS](/concepts/signing-keys).\n\nPremium, Scale, and Enterprise organizations can act as both prover and verifier.\n\n## Upgrading and Downgrading\n\nTier changes are managed by Bind administrators. When downgrading from a higher tier, excess resources are handled automatically:\n\n- **API keys** — the most recently used keys are kept; excess keys are revoked\n- **Signing keys** — the default key is preserved; excess keys are revoked\n- **Webhooks** — the most recently active webhooks are kept; excess webhooks are disabled\n- **Users** — the most recently active users are kept; excess users are deactivated\n- **Policies** — the most recently created policies are kept; excess policies are archived\n- **Extractors** — the most recently created extractors are kept; public extractors with installations are preserved\n\nA `downgradedAt` timestamp is recorded on the organization for audit purposes.\n\n## Next Steps\n\n- [Organization Management Guide](/guides/org-management) — Inviting users, managing keys, and configuring your org\n- [Signing Keys](/concepts/signing-keys) — How credential signing works\n- [Authentication](/api/authentication) — API key and JWT authentication details",
  },
  {
    uri: "bind://docs/concepts/overview",
    title: "How Bind Works",
    content: "# How Bind Works\n\nBind is a full-stack attestation platform that takes data from any HTTPS API and turns it into privacy-preserving, verifiable credentials.\n\n## The Flow\n\n```mermaid\nflowchart LR\n    A[\"1. Witness\\nData via zkTLS\"] --> B[\"2. Extract\\nClaims via Extractors\"]\n    B --> C[\"3. Prove\\nPolicy via ZK Proof\"]\n    C --> D[\"4. Issue\\nW3C VC Credential\"]\n```\n\n### 1. Witness Data\n\nA user authenticates with an external service (e.g., Coinbase, DIMO). Bind's zkTLS witness cryptographically observes the HTTPS response, proving the data came from the claimed source — without storing credentials or raw data.\n\n### 2. Extract Claims\n\nAn [extractor](/concepts/extractors) defines which fields to pull from the API response using JSONPath expressions. Only the relevant data points are extracted — not the full response.\n\n### 3. Generate Proof\n\nA [policy](/concepts/policies) defines the rules to evaluate. Bind generates a zero-knowledge proof that the extracted data satisfies the policy — without revealing the underlying inputs. The proof is mathematically verifiable by anyone.\n\n### 4. Issue Credential\n\nThe result is packaged as a [W3C Verifiable Credential](/concepts/credentials) signed with ECDSA P-256. Credentials can optionally be anchored on-chain for immutable proof of existence.\n\n## Authentication\n\nBind supports two authentication methods:\n\n| Method | Use Case | Header |\n|--------|----------|--------|\n| **API Key** | Programmatic access (prove, verify, share) | `X-API-Key: idbr_<keyId>_<secret>` |\n| **JWT** | Dashboard and management endpoints | `Authorization: Bearer <token>` |\n\nAPI keys are used for runtime operations like submitting prove jobs and verifying proofs. JWT tokens are obtained by logging in and are used for management operations like configuring extractors, webhooks, and organization settings.\n\nSee [Authentication](/api/authentication) for details.\n\n## Security Model\n\n### Privacy Guarantees\n\n**What verifiers see:**\n- Policy output (risk score, pass/fail, band)\n- Policy identifier (which rules were evaluated)\n- Timestamp\n- Cryptographic proof of validity\n\n**What verifiers don't see:**\n- Raw data from APIs\n- Intermediate computation steps\n- Policy implementation details\n- Any data beyond the specific claim\n\n### Cryptography\n\n| Purpose | Algorithm |\n|---------|-----------|\n| Credential signing | ECDSA P-256 |\n| zkTLS attestation | Ed25519 |\n| Webhook signatures | HMAC-SHA256 |\n| Proof generation | Zero-knowledge proofs |\n\n## Data Model\n\n```\nOrganization\n├── API Keys           # Programmatic access\n├── Signing Keys       # Credential signing (JWKS endpoint)\n├── Policies           # What to prove\n├── Extractors         # Where to get data\n├── Prove Jobs         # Proof generation requests\n├── Credentials        # Issued W3C VCs\n├── Webhooks           # Event notifications\n└── Users              # Dashboard access\n```",
  },
  {
    uri: "bind://docs/concepts/policies",
    title: "Policies",
    content: "# Policies\n\nA **policy** is a declarative specification that defines what Bind should prove about a subject (person, vehicle, device, organization). Policies transform raw data into privacy-preserving credentials.\n\n## Public and Private Specs\n\nEvery policy has two parts:\n\n| Part | Visible To | Contains |\n|------|-----------|----------|\n| **Public Spec** | Verifiers, marketplace | Metadata, output claims, validity rules, disclosure settings |\n| **Private Spec** | Bind only | Input definitions, extraction rules, evaluation logic |\n\nThis separation ensures verifiers know *what* is being proven without knowing *how*.\n\n## Output Types\n\n| Type | Description | Example |\n|------|-------------|---------|\n| `PASS_FAIL` | Boolean result | \"Driver meets safety criteria\" |\n| `SCORE` | Numeric value (0-100) | \"Safety score: 85\" |\n| `BAND` | Categorical tier | \"Risk tier: LOW/MEDIUM/HIGH\" |\n| `CONST` | Fixed value | \"Policy version: 1.0\" |\n\n## Policy Spec Structure\n\n```typescript\n// Public Spec (visible to verifiers)\ninterface PublicPolicySpec {\n  id: string;                    // e.g., \"dimo:safe-driver:v1\"\n  version: SemVer;\n  metadata: {\n    title: string;\n    description: string;\n    namespace: string;\n    authors: string[];\n  };\n  subject: {\n    type: \"vehicle\" | \"device\" | \"user\" | \"organization\";\n    identifier: string;\n  };\n  outputs: OutputClaimSpec[];\n  validity: {\n    duration: Duration;          // ISO 8601 (e.g., \"P90D\")\n    renewable: boolean;\n  };\n  disclosure: {\n    level: \"full\" | \"partial\" | \"minimal\";\n    redactedFields: string[];\n  };\n  integrityHash: string;         // SHA256 of canonical private spec\n}\n\n// Private Spec (known only to Bind)\ninterface FullPolicySpec extends PublicPolicySpec {\n  inputs: InputSpec[];\n  rules: RuleSpec[];\n  evaluation: EvaluationSpec;\n  proving: ProvingSpec;\n}\n```\n\n## Input Sources\n\nPolicies can pull data from five source kinds:\n\n| Source Kind | Description |\n|-------------|-------------|\n| `dimo` | DIMO telematics API |\n| `api` | External API endpoint |\n| `static` | User-provided / direct value |\n| `composed` | Output from another policy (composition) |\n| `zktls` | zkTLS witnessed HTTPS response |\n\n:::note Tier Restrictions\n`composed` and `zktls` source kinds require **Premium** or **Enterprise** tier. Basic-tier organizations can use `dimo`, `api`, and `static`. See [Source Kind Restrictions](/concepts/organizations#input-source-kind-restrictions) for details.\n:::\n\n## Rule Expressions\n\nRules are assertions written as expression trees:\n\n```json\n{\n  \"type\": \"and\",\n  \"children\": [\n    {\n      \"type\": \"cmp\",\n      \"operator\": \">\",\n      \"left\": { \"type\": \"ref\", \"path\": \"inputs.milesDriven\" },\n      \"right\": { \"type\": \"const\", \"value\": 10000 }\n    },\n    {\n      \"type\": \"cmp\",\n      \"operator\": \"<\",\n      \"left\": { \"type\": \"ref\", \"path\": \"inputs.hardBrakeRate\" },\n      \"right\": { \"type\": \"const\", \"value\": 5 }\n    }\n  ]\n}\n```\n\nSupported operators: `>`, `>=`, `<`, `<=`, `==`, `!=`, `+`, `-`, `*`, `/`, `and`, `or`, `not`\n\n## Automatic Circuit Generation\n\nWhen you save a policy, Bind automatically generates the underlying cryptographic circuit, compiles it, and prepares it for proof generation. No manual circuit development is required — just define your policy spec and Bind handles the rest.\n\nYou can trigger circuit generation via the API:\n\n```bash\nPOST /api/orgs/:orgId/policies/:policyId/generate-circuit\n```\n\n## Visual Policy Builder\n\nThe dashboard includes a drag-and-drop policy editor for building policies without writing JSON. See the [Policy Authoring Guide](/guides/policy-authoring) for details on using it.\n\n## Visibility and Marketplace\n\n| State | Who Can See | Who Can Use | Mutable |\n|-------|-------------|-------------|---------|\n| **Private** | Creating org only | Creating org only | Yes |\n| **Public** | Everyone | Everyone (via install) | No |\n\nPublishing is a **one-way transition**. Once public, policies are immutable to ensure reproducibility.\n\n## Next Steps\n\n- [Policy Authoring Guide](/guides/policy-authoring) — Step-by-step guide to creating policies\n- [Marketplace](/concepts/marketplace) — Browse and install public policies",
  },
  {
    uri: "bind://docs/concepts/proof-types",
    title: "Proof Types",
    content: "# Proof Types\n\nBind supports two fundamentally different ways to supply data for a zero-knowledge proof: **direct proofs** and **zkWitness proofs**. The distinction determines where the input data comes from and what trust guarantees the resulting credential carries.\n\n## Direct Proof vs zkWitness Proof\n\n```mermaid\nflowchart TD\n    subgraph Direct[\"Direct Proof\"]\n        A1[Application] -->|provides data| B1[Bind]\n        B1 -->|generates ZK proof| C1[Credential]\n    end\n    subgraph Witness[\"zkWitness Proof\"]\n        A2[External API] -->|HTTPS response| W[zkTLS Witness]\n        W -->|attested data| B2[Bind]\n        B2 -->|generates ZK proof| C2[Credential]\n    end\n```\n\n### Direct Proof\n\nIn a direct proof, your application provides the input data directly to Bind. The data is not witnessed or attested by a third party — it comes from your system.\n\n**Policy input configuration:**\n```json\n{\n  \"id\": \"income\",\n  \"source\": { \"kind\": \"static\" },\n  \"signal\": \"income\",\n  \"valueType\": \"number\",\n  \"time\": { \"mode\": \"point\" },\n  \"aggregation\": { \"op\": \"latest\" },\n  \"unit\": \"USD\"\n}\n```\n\n**Submitting a direct proof:**\n```typescript\nconst { jobId } = await client.submitProveJob('bind.demo.credit_score.v0_1_0', {\n  income: '5000',\n  debt: '250000',\n  credit_history_months: '48',\n});\n```\n\nDirect proofs are useful for scenarios where the prover organization is the authoritative source of the data — for example, a fintech platform proving properties about its own user data, or an IoT platform attesting to device readings it collected.\n\n### zkWitness Proof\n\nIn a zkWitness proof, the input data is fetched from an external HTTPS API and cryptographically attested by a Bind witness. The witness observes the TLS session and signs the response, proving the data came from the claimed source without storing credentials or raw data.\n\n**Policy input configuration:**\n```json\n{\n  \"id\": \"mileage_90d\",\n  \"source\": {\n    \"kind\": \"zktls\",\n    \"config\": {\n      \"domain\": \"api.dimo.zone\",\n      \"path\": \"/v2/vehicles/:id/telemetry\",\n      \"trust\": \"witnessed\",\n      \"extractor\": \"dimo-telematics\"\n    }\n  },\n  \"signal\": \"vehicle.milesDriven\",\n  \"valueType\": \"number\",\n  \"unit\": \"miles\",\n  \"time\": { \"mode\": \"relative\", \"lookback\": \"90d\" },\n  \"aggregation\": { \"op\": \"sum\" }\n}\n```\n\nzkWitness proofs carry stronger trust guarantees because the data provenance is cryptographically verified. A verifier knows the data came from the specific external API, not just from the prover's claim.\n\n## Trust Model Comparison\n\n| | Direct Proof | zkWitness Proof |\n|---|---|---|\n| **Data source** | Application-provided | External HTTPS API |\n| **Attestation** | None — prover is trusted | zkTLS witness signature |\n| **Trust assumption** | Prover is honest about input data | Data provenance is cryptographically verified |\n| **Use case** | First-party data, testing, internal attestations | Third-party data verification, regulatory compliance |\n| **Input source kind** | `static` | `zktls`, `dimo`, or other witnessed sources |\n\nBoth proof types produce the same kind of output — a zero-knowledge proof that the data satisfies the policy, and a W3C Verifiable Credential signed with your organization's [signing key](/concepts/signing-keys). The difference is in the trust chain backing the inputs.\n\n## Mixing Input Types\n\nA single policy can combine direct and witnessed inputs. For example, a lending risk policy might pull credit data via zkTLS from a financial API while accepting the loan amount as a direct input from the lending platform:\n\n```json\n{\n  \"inputs\": [\n    {\n      \"id\": \"credit_score\",\n      \"source\": {\n        \"kind\": \"zktls\",\n        \"config\": {\n          \"domain\": \"api.creditbureau.com\",\n          \"path\": \"/v1/score\",\n          \"trust\": \"witnessed\",\n          \"extractor\": \"credit-score\"\n        }\n      },\n      \"signal\": \"score\",\n      \"valueType\": \"number\"\n    },\n    {\n      \"id\": \"loan_amount\",\n      \"source\": { \"kind\": \"static\" },\n      \"signal\": \"loan_amount\",\n      \"valueType\": \"number\",\n      \"unit\": \"USD\"\n    }\n  ]\n}\n```\n\nWhen mixing input types, the resulting credential reflects the weakest trust guarantee across all inputs. Verifiers can inspect the policy's public spec to understand which inputs are witnessed and which are direct.\n\n## Verification Modes\n\nIndependently of the proof type, you choose a **verification mode** that determines how the proof is validated after generation:\n\n| Mode | Description | Use Case |\n|------|-------------|----------|\n| `zkverify` | Proof submitted to zkVerify network for on-chain verification | Production, regulatory compliance, auditability |\n| `self_verify` | Proof artifacts returned for client-side verification | Development, low-cost scenarios, private verification |\n\nVerification mode is specified when submitting a prove job:\n\n```typescript\nconst { jobId } = await client.submitProveJob(circuitId, inputs, {\n  verificationMode: 'zkverify',\n});\n```\n\n## Multi-Witness Attestations\n\n:::info\nMulti-witness attestations are available on **Premium** and **Enterprise** tiers.\n:::\n\nFor high-assurance use cases, zkWitness proofs can require multiple independent witnesses to attest to the same data. This eliminates single-point-of-trust risk — even if one witness is compromised, the attestation remains valid as long as the threshold is met.\n\n### Witness Modes\n\n| Mode | Description |\n|------|-------------|\n| `single` | One witness attests to the data (default) |\n| `threshold` | M-of-N witnesses must agree (e.g., 3 of 5) |\n| `unanimous` | All configured witnesses must agree |\n\n### Witness Types\n\n| Type | Description |\n|------|-------------|\n| `primary` | Bind Protocol's managed witness infrastructure |\n| `self_hosted` | Witness node operated by your organization |\n| `third_party` | Independent witness operator |\n\nMulti-witness mode is configured at the zkTLS session level. See [zkTLS Attestations](/concepts/zktls) for session configuration details.\n\n### Example: Threshold Attestation\n\n```json\n{\n  \"witnessConfig\": {\n    \"mode\": \"threshold\",\n    \"threshold\": 3,\n    \"witnesses\": [\"witness_bind_primary\", \"witness_acme_corp\", \"witness_independent_1\", \"witness_independent_2\", \"witness_independent_3\"]\n  }\n}\n```\n\nIn threshold mode, the attestation succeeds when at least `threshold` witnesses produce matching signatures. This is suitable for high-value credentials where independent verification of data provenance is required.\n\n## Choosing the Right Proof Type\n\n| Scenario | Recommended Type |\n|----------|-----------------|\n| Prototyping and testing | Direct proof with `self_verify` |\n| First-party data (you own the data source) | Direct proof |\n| Third-party data (external APIs) | zkWitness proof |\n| Regulatory or compliance credentials | zkWitness proof with `zkverify` |\n| High-value attestations | zkWitness proof with multi-witness |\n\n## Next Steps\n\n- [Proof Generation Guide](/guides/proof-generation) — End-to-end proof generation walkthrough\n- [zkTLS Attestations](/concepts/zktls) — How zkTLS witnessing works\n- [Policies](/concepts/policies) — Defining what to prove",
  },
  {
    uri: "bind://docs/concepts/signing-keys",
    title: "Signing Keys",
    content: "# Signing Keys\n\nSigning keys are how your organization establishes trust. When Bind issues a credential on your behalf, it signs the W3C Verifiable Credential with your organization's signing key. Verifiers validate that signature using your public key, published at a standard JWKS endpoint.\n\n## How Signing Keys Work\n\n```mermaid\nflowchart LR\n    A[\"Prover Org\\nSigning Key\"] -->|signs| B[\"W3C VC-JWT\\nCredential\"]\n    B -->|shared with| C[Verifier Org]\n    C -->|fetches| D[\"JWKS Endpoint\\n/.well-known/jwks.json\"]\n    D -->|validates signature| C\n```\n\n1. Your organization creates one or more signing keys\n2. When a prove job completes, Bind signs the resulting credential with your **default signing key**\n3. The credential is a W3C VC-JWT containing the policy output, subject identifier, and validity period\n4. Verifiers fetch your organization's public keys from the JWKS endpoint and verify the JWT signature\n\n## Supported Algorithms\n\n| Algorithm | Curve | Use Case |\n|-----------|-------|----------|\n| `ES256` | P-256 (NIST) | Default. Widely supported across web platforms and identity standards |\n| `ES256K` | secp256k1 | Ethereum and blockchain-compatible credential verification |\n\nBoth algorithms produce ECDSA signatures. Choose based on your verifier ecosystem — `ES256` for general web/enterprise use, `ES256K` if your verifiers operate on-chain.\n\n## Creating a Signing Key\n\n```bash\ncurl -X POST https://api.bindprotocol.com/api/orgs/:orgId/signing-keys \\\n  -H \"Authorization: Bearer <token>\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"alias\": \"production-2026\",\n    \"algorithm\": \"ES256\",\n    \"isDefault\": true\n  }'\n```\n\n| Field | Type | Default | Description |\n|-------|------|---------|-------------|\n| `alias` | string | — | Unique identifier (alphanumeric, hyphens, underscores) |\n| `algorithm` | string | `ES256` | `ES256` or `ES256K` |\n| `isDefault` | boolean | `false` | Use as the default key for credential signing |\n\nThe response includes the public key in JWK format. Private keys are managed by Bind's key management infrastructure and are never exposed.\n\n```json\n{\n  \"id\": \"sk_abc123\",\n  \"keyAlias\": \"production-2026\",\n  \"algorithm\": \"ES256\",\n  \"status\": \"active\",\n  \"isDefault\": true,\n  \"publicKeyJwk\": {\n    \"kty\": \"EC\",\n    \"crv\": \"P-256\",\n    \"x\": \"...\",\n    \"y\": \"...\",\n    \"kid\": \"production-2026\",\n    \"use\": \"sig\"\n  }\n}\n```\n\n## Signing Key Limits\n\n| Tier | Max Signing Keys |\n|------|-----------------|\n| Basic | 0 |\n| Premium | 5 |\n| Scale | 10 |\n| Verifier | 1 |\n| Enterprise | Unlimited |\n\nBasic-tier organizations use Bind's system signing key for credentials. Premium and above can create their own signing keys (self-sign) for independent credential issuance.\n\n## JWKS Endpoint\n\nEvery organization has a public JWKS endpoint that verifiers use to fetch your active signing keys:\n\n```\nGET /api/orgs/:orgId/.well-known/jwks.json\n```\n\n**Auth:** None (public)\n\nThis endpoint returns all active signing keys in standard JWKS format:\n\n```json\n{\n  \"keys\": [\n    {\n      \"kty\": \"EC\",\n      \"crv\": \"P-256\",\n      \"x\": \"...\",\n      \"y\": \"...\",\n      \"kid\": \"production-2026\",\n      \"use\": \"sig\"\n    }\n  ]\n}\n```\n\nVerifiers should cache this response but refresh periodically (recommended: every 24 hours) to pick up key rotations.\n\n## Key Rotation\n\nKey rotation lets you transition to a new signing key without invalidating existing credentials. The recommended approach:\n\n1. **Create a new key** — add a new signing key with a descriptive alias (e.g., `production-2026-q2`)\n2. **Set it as default** — new credentials will be signed with the new key\n3. **Wait for old credentials to expire** — existing credentials remain valid because the old public key is still in your JWKS\n4. **Revoke the old key** — once all credentials signed with the old key have expired, remove it\n\n### Set Default Key\n\n```bash\ncurl -X PATCH https://api.bindprotocol.com/api/orgs/:orgId/signing-keys/:alias \\\n  -H \"Authorization: Bearer <token>\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{ \"isDefault\": true }'\n```\n\n### Revoke a Key\n\n```bash\ncurl -X DELETE https://api.bindprotocol.com/api/orgs/:orgId/signing-keys/:alias \\\n  -H \"Authorization: Bearer <token>\"\n```\n\n:::warning\nRevoking a signing key removes it from your JWKS endpoint. Any credentials signed with that key will **fail verification** if a verifier fetches a fresh JWKS after revocation. Only revoke keys after all associated credentials have expired or been replaced.\n:::\n\n## Credential Signing Flow\n\nWhen a prove job completes and a credential is issued:\n\n1. Bind retrieves your organization's **default signing key**\n2. The credential payload (policy output, subject, validity) is assembled into a VC-JWT\n3. The JWT is signed using the signing key's private key (managed by Bind's KMS)\n4. The signed credential is stored and available for sharing\n\nThe `kid` (Key ID) header in the JWT matches the `kid` in your JWKS endpoint, so verifiers know exactly which key to use for validation.\n\n## Verification\n\nVerifiers validate credentials using standard JWT verification:\n\n1. Parse the VC-JWT and extract the `kid` from the JWT header\n2. Fetch the issuer's JWKS from `GET /api/orgs/:issuerId/.well-known/jwks.json`\n3. Find the key matching the `kid`\n4. Verify the JWT signature using the public key\n5. Check the credential hasn't expired and hasn't been [revoked](/api/credentials)\n\nSee [Verification](/api/verify) for the API-based verification flow.\n\n## Next Steps\n\n- [Organizations and Tiers](/concepts/organizations) — Signing key limits by tier\n- [Credentials](/concepts/credentials) — W3C Verifiable Credential format\n- [Organizations API](/api/organizations) — Full signing key endpoint reference",
  },
  {
    uri: "bind://docs/concepts/zktls",
    title: "zkTLS Attestations",
    content: "# zkTLS Attestations\n\nA **zkTLS attestation** is a cryptographically signed statement that a witness observed specific data in an HTTPS response. It proves data provenance without requiring the data source to integrate with Bind.\n\n## How zkTLS Works\n\n```mermaid\nflowchart TD\n    A[User Browser] --> B[Witness Proxy]\n    B --> C[Target Service]\n    C --> B\n    B --> D[\"1. Intercept HTTPS response\"]\n    D --> E[\"2. Verify TLS certificate chain\"]\n    E --> F[\"3. Extract claims via JSONPath\"]\n    F --> G[\"4. Sign attestation (Ed25519)\"]\n    G --> H[\"5. Return to API\"]\n```\n\n1. User authenticates with a service (e.g., Coinbase, DIMO)\n2. Witness proxy intercepts the TLS session\n3. Claims are extracted via JSONPath expressions from the extractor config\n4. Witness signs the extracted claims with Ed25519\n5. Attestation is stored and available for proof generation\n\n## Attestation Structure\n\n```typescript\ninterface ZkTlsAttestation {\n  sessionId: string;\n  extractorId: string;\n  extractorVersion: string;\n  claims: Record<string, any>;   // Extracted data\n\n  // Single witness (v1)\n  signature?: string;            // Ed25519 signature\n  witnessId?: string;\n\n  // Multi-party (v2)\n  signatures?: WitnessSignature[];\n  threshold?: number;\n\n  nonce: string;                 // Replay protection\n  expiresAt: Date;\n\n  ctVerified: boolean;           // Certificate transparency\n  ctLogs?: string[];\n}\n```\n\n## Session TTL\n\nzkTLS sessions have a 5-minute TTL. Once a session is created, the user must complete authentication with the target service within that window.\n\n## Multi-Party Witnessing\n\nBind supports multiple witness configurations for higher assurance:\n\n| Mode | Description | Trust Model | Tier Requirement |\n|------|-------------|-------------|------------------|\n| **Single** (default) | Bind's primary witness | Trust Bind | All tiers |\n| **Threshold** (M-of-N) | Require M of N witnesses to sign | Distributed trust | Premium+ |\n| **Unanimous** | All witnesses must sign | Maximum assurance | Premium+ |\n\nMulti-witness mode is available to Premium, Scale, and Enterprise organizations. Configure it via the `witnessConfig` parameter when [creating a zkTLS session](/api/zktls).\n\n## Self-Hosted Witnesses\n\nEnterprise organizations can register and use their own self-hosted witnesses. This provides maximum control over the attestation process — your witness runs in your infrastructure, signs with your keys, and only you control what domains it attests to.\n\n### Registering a Self-Hosted Witness\n\n```bash\ncurl -X POST https://api.bindprotocol.com/api/orgs/:orgId/witnesses \\\n  -H \"Authorization: Bearer <token>\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"witnessId\": \"acme:my-witness\",\n    \"name\": \"ACME Internal Witness\",\n    \"publicKey\": \"<ed25519-public-key>\",\n    \"allowedDomains\": [\"api.internal.acme.com\"],\n    \"endpoint\": \"https://witness.acme.com\"\n  }'\n```\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `witnessId` | string | Yes | Unique identifier for the witness |\n| `name` | string | Yes | Display name |\n| `publicKey` | string | Yes | Ed25519 public key for signature verification |\n| `allowedDomains` | string[] | Yes | Domains this witness is authorized to attest |\n| `description` | string | No | Description of the witness |\n| `endpoint` | string | No | Witness service endpoint URL |\n\nSelf-hosted witnesses can be referenced in the `witnessConfig.witnesses` array when creating zkTLS sessions. If any witness in the session is self-hosted, the organization must have the Enterprise tier.\n\n## Browser Extension Mode (Coming Soon)\n\nA browser extension mode for passive data capture is in development. This will allow capturing data from web pages the user visits without requiring explicit API calls.\n\n## Next Steps\n\n- [API: zkTLS Endpoints](/api/zktls) — Create sessions and retrieve attestations\n- [Extractors](/concepts/extractors) — Configure what data to extract",
  },
  {
    uri: "bind://docs/guides/advanced-policies",
    title: "Advanced Policy Guide",
    content: "# Advanced Policy Guide\n\nThis guide covers advanced policy patterns — using policies as inputs to other policies, building complex rule trees, working with scored evaluations, and combining multiple data sources. If you're new to policies, start with the [Policy Authoring Guide](/guides/policy-authoring).\n\n## Policy Composition\n\n:::info Premium Feature\nPolicy composition (`composed` source kind) requires **Premium** or **Enterprise** tier. Basic-tier organizations cannot use policies as inputs. See [Organizations and Tiers](/concepts/organizations#input-source-kind-restrictions) for the full breakdown.\n:::\n\nA policy can reference the output of another policy as an input. This lets you build layered attestation pipelines where a higher-level policy consumes the results of lower-level policies instead of raw data.\n\n```mermaid\nflowchart LR\n    A[\"Policy A\\nSafe Driver\\n(PASS_FAIL)\"] --> C[\"Policy C\\nInsurance Eligibility\\n(BAND)\"]\n    B[\"Policy B\\nVehicle History\\n(SCORE)\"] --> C\n    C --> D[Credential]\n```\n\n### Why Compose Policies?\n\nComposition keeps individual policies focused and reusable. A \"Safe Driver\" policy can be authored once and consumed by multiple higher-level policies — an insurance eligibility policy, a fleet management policy, and a ride-sharing qualification policy can all reference the same underlying driver safety attestation.\n\n### Defining a Composed Input\n\nTo reference another policy's output as an input, use the `composed` source kind:\n\n```json\n{\n  \"inputs\": [\n    {\n      \"id\": \"driver_safety\",\n      \"source\": {\n        \"kind\": \"composed\",\n        \"ref\": \"dimo:safe-driver:v1\",\n        \"config\": {\n          \"output\": \"safeDriver\"\n        }\n      },\n      \"signal\": \"safeDriver\",\n      \"valueType\": \"boolean\",\n      \"time\": { \"mode\": \"point\" },\n      \"aggregation\": { \"op\": \"latest\" }\n    },\n    {\n      \"id\": \"vehicle_risk_score\",\n      \"source\": {\n        \"kind\": \"composed\",\n        \"ref\": \"dimo:vehicle-risk:v1\",\n        \"config\": {\n          \"output\": \"riskScore\"\n        }\n      },\n      \"signal\": \"riskScore\",\n      \"valueType\": \"number\",\n      \"time\": { \"mode\": \"point\" },\n      \"aggregation\": { \"op\": \"latest\" }\n    }\n  ]\n}\n```\n\n| Field | Description |\n|-------|-------------|\n| `source.kind` | `\"composed\"` — indicates this input comes from another policy |\n| `source.ref` | The policy ID of the upstream policy (e.g., `\"dimo:safe-driver:v1\"`) |\n| `source.config.output` | The name of the output claim to consume from the upstream policy |\n\n### Execution Order\n\nWhen a composed policy is evaluated, Bind resolves the dependency graph and evaluates upstream policies first. If Policy C depends on Policy A and Policy B, Bind ensures A and B complete before evaluating C. Circular dependencies are rejected at policy creation time.\n\n### Type Mapping\n\nUpstream policy outputs are typed (`boolean`, `number`, `string`, `enum`). If the output type doesn't match what your rule expects, use a **mapper** to convert it. For example, a BAND output produces an enum (`\"LOW\"`, `\"MEDIUM\"`, `\"HIGH\"`) that you might want to map to a numeric value for scoring:\n\n```json\n{\n  \"id\": \"risk_numeric\",\n  \"source\": {\n    \"kind\": \"composed\",\n    \"ref\": \"dimo:vehicle-risk:v1\",\n    \"config\": {\n      \"output\": \"riskBand\",\n      \"mapper\": {\n        \"inputType\": \"enum\",\n        \"outputType\": \"number\",\n        \"mappings\": [\n          { \"from\": \"LOW\", \"to\": 100 },\n          { \"from\": \"MEDIUM\", \"to\": 50 },\n          { \"from\": \"HIGH\", \"to\": 0 }\n        ]\n      }\n    }\n  },\n  \"signal\": \"riskNumeric\",\n  \"valueType\": \"number\",\n  \"time\": { \"mode\": \"point\" },\n  \"aggregation\": { \"op\": \"latest\" }\n}\n```\n\n### Visual Policy Builder\n\nThe dashboard's drag-and-drop editor supports composition through **Policy nodes**. Drag a Policy node onto the canvas, select the upstream policy and version, then connect its outputs to Reference or Mapper nodes in your rule graph.\n\n---\n\n## Complex Rule Trees\n\nRules are expression trees built from references, constants, comparisons, and logical/arithmetic operators. Simple policies use flat comparisons, but advanced policies often need deeply nested logic.\n\n### Conditional Rules with Preconditions\n\nUse `and`/`or` to express conditional logic:\n\n```json\n{\n  \"id\": \"high_mileage_safe_braking\",\n  \"description\": \"High-mileage drivers must have excellent braking behavior\",\n  \"assert\": {\n    \"type\": \"or\",\n    \"args\": [\n      {\n        \"type\": \"cmp\",\n        \"cmp\": \"<\",\n        \"left\": { \"type\": \"ref\", \"inputId\": \"milesDriven\" },\n        \"right\": { \"type\": \"const\", \"value\": 20000 }\n      },\n      {\n        \"type\": \"cmp\",\n        \"cmp\": \"<\",\n        \"left\": { \"type\": \"ref\", \"inputId\": \"hardBrakeRate\" },\n        \"right\": { \"type\": \"const\", \"value\": 2 }\n      }\n    ]\n  },\n  \"severity\": \"fail\"\n}\n```\n\nThis rule passes if the driver has low mileage (under 20k) **or** has an excellent hard brake rate (under 2%). High-mileage drivers are held to a stricter standard.\n\n### Computed Values in Rules\n\nUse arithmetic operators to derive values within a rule expression:\n\n```json\n{\n  \"id\": \"debt_to_income\",\n  \"description\": \"Debt-to-income ratio must be 50% or less\",\n  \"assert\": {\n    \"type\": \"cmp\",\n    \"cmp\": \"<=\",\n    \"left\": {\n      \"type\": \"op\",\n      \"op\": \"/\",\n      \"args\": [\n        { \"type\": \"ref\", \"inputId\": \"debt\" },\n        { \"type\": \"ref\", \"inputId\": \"income\" }\n      ]\n    },\n    \"right\": { \"type\": \"const\", \"value\": 0.5 }\n  },\n  \"severity\": \"fail\"\n}\n```\n\n### Negation\n\nInvert any expression with `not`:\n\n```json\n{\n  \"id\": \"not_blacklisted\",\n  \"description\": \"Vehicle must not be on the blacklist\",\n  \"assert\": {\n    \"type\": \"not\",\n    \"expr\": {\n      \"type\": \"cmp\",\n      \"cmp\": \"==\",\n      \"left\": { \"type\": \"ref\", \"inputId\": \"blacklisted\" },\n      \"right\": { \"type\": \"const\", \"value\": true }\n    }\n  },\n  \"severity\": \"fail\"\n}\n```\n\n### Set Membership\n\nUse `in` and `notIn` comparators to check if a value belongs to a set:\n\n```json\n{\n  \"id\": \"approved_country\",\n  \"description\": \"User must be in an approved jurisdiction\",\n  \"assert\": {\n    \"type\": \"cmp\",\n    \"cmp\": \"in\",\n    \"left\": { \"type\": \"ref\", \"inputId\": \"countryCode\" },\n    \"right\": { \"type\": \"const\", \"value\": [\"US\", \"CA\", \"GB\", \"DE\", \"FR\"] }\n  },\n  \"severity\": \"fail\"\n}\n```\n\n---\n\n## Scored Evaluation\n\nScored evaluation assigns weighted points to rules, producing a numeric output instead of a binary pass/fail. This is powerful for risk assessment, creditworthiness, and any domain where gradations matter.\n\n### Score Configuration\n\n```json\n{\n  \"evaluation\": {\n    \"kind\": \"SCORE\",\n    \"scoreRange\": { \"min\": 0, \"max\": 100 },\n    \"baseline\": 50,\n    \"contributions\": [\n      { \"ruleId\": \"mileage_check\", \"points\": 20, \"whenPasses\": true },\n      { \"ruleId\": \"braking_check\", \"points\": 30, \"whenPasses\": true },\n      { \"ruleId\": \"speeding_check\", \"points\": 20, \"whenPasses\": true },\n      { \"ruleId\": \"accident_history\", \"points\": -30, \"whenPasses\": false }\n    ]\n  }\n}\n```\n\n| Field | Description |\n|-------|-------------|\n| `scoreRange` | Minimum and maximum score bounds |\n| `baseline` | Starting score before rule contributions are applied |\n| `contributions[].ruleId` | Which rule this contribution is tied to |\n| `contributions[].points` | Points to add (positive) or subtract (negative) |\n| `contributions[].whenPasses` | Whether points are applied when the rule passes (`true`) or fails (`false`) |\n\nIn this example, the baseline is 50. A driver who passes all positive checks gets 50 + 20 + 30 + 20 = 120, clamped to the max of 100. A driver who fails the accident history check gets 50 − 30 = 20.\n\n### BAND Derivation from Scores\n\nA BAND output converts a numeric score into categorical tiers:\n\n```json\n{\n  \"outputs\": [\n    {\n      \"name\": \"riskBand\",\n      \"type\": \"enum\",\n      \"derive\": {\n        \"kind\": \"BAND\",\n        \"from\": \"SCORE\",\n        \"bands\": [\n          { \"label\": \"HIGH\", \"minInclusive\": 0, \"maxExclusive\": 40 },\n          { \"label\": \"MEDIUM\", \"minInclusive\": 40, \"maxExclusive\": 70 },\n          { \"label\": \"LOW\", \"minInclusive\": 70, \"maxExclusive\": 101 }\n        ]\n      }\n    }\n  ]\n}\n```\n\nBands are evaluated in order. The score falls into the first band where `minInclusive <= score < maxExclusive`.\n\n---\n\n## Rule Severity\n\nEvery rule has a severity that determines its effect on evaluation:\n\n| Severity | Effect |\n|----------|--------|\n| `fail` | In PASS_FAIL mode, causes the policy to fail. In SCORE mode, triggers the associated point contribution |\n| `warn` | Logged in evaluation results but does not affect the output. Useful for monitoring thresholds you may want to enforce later |\n| `info` | Informational only. Recorded for audit purposes |\n\n---\n\n## Multi-Input Policies\n\n:::info Source Kind Availability\nNot all source kinds are available on every tier. `composed` and `zktls` require **Premium** or **Enterprise**. Basic-tier organizations can use `dimo`, `api`, and `static` sources. See [Source Kind Restrictions](/concepts/organizations#input-source-kind-restrictions).\n:::\n\nPolicies become powerful when they combine data from multiple sources. A single policy can mix zkTLS extractors, direct inputs, composed policy outputs, and aggregations:\n\n```json\n{\n  \"inputs\": [\n    {\n      \"id\": \"mileage_90d\",\n      \"source\": { \"kind\": \"dimo\", \"api\": \"telemetry\" },\n      \"signal\": \"vehicle.milesDriven\",\n      \"valueType\": \"number\",\n      \"time\": { \"mode\": \"relative\", \"lookback\": \"90d\" },\n      \"aggregation\": { \"op\": \"sum\" }\n    },\n    {\n      \"id\": \"hard_brake_rate\",\n      \"source\": { \"kind\": \"dimo\", \"api\": \"telemetry\" },\n      \"signal\": \"driving.events.hardBrake\",\n      \"valueType\": \"number\",\n      \"time\": { \"mode\": \"relative\", \"lookback\": \"90d\" },\n      \"aggregation\": { \"op\": \"windowedRate\", \"per\": \"1d\" }\n    },\n    {\n      \"id\": \"kyc_verified\",\n      \"source\": {\n        \"kind\": \"zktls\",\n        \"config\": {\n          \"domain\": \"api.provider.com\",\n          \"path\": \"/v1/user/kyc\",\n          \"trust\": \"witnessed\",\n          \"extractor\": \"kyc-status\"\n        }\n      },\n      \"signal\": \"verified\",\n      \"valueType\": \"boolean\"\n    },\n    {\n      \"id\": \"coverage_amount\",\n      \"source\": { \"kind\": \"static\" },\n      \"signal\": \"coverage_amount\",\n      \"valueType\": \"number\",\n      \"unit\": \"USD\"\n    }\n  ]\n}\n```\n\nThis policy pulls vehicle telemetry from DIMO, verifies KYC status via a witnessed external API, and accepts a coverage amount directly from the application.\n\n---\n\n## Aggregation Patterns\n\nWhen working with time-series data, aggregations reduce a window of values to a single scalar for use in rules.\n\n| Operator | Description |\n|----------|-------------|\n| `latest` | Most recent value |\n| `sum` | Total over the window |\n| `avg` | Mean value |\n| `min` / `max` | Extremes |\n| `count` | Number of data points |\n| `p50` / `p90` / `p95` / `p99` | Percentiles |\n| `distinctCount` | Number of unique values |\n| `windowedRate` | Rate per time unit (e.g., events per day) |\n\n### Example: 90th Percentile Speed\n\n```json\n{\n  \"id\": \"speed_p90\",\n  \"source\": { \"kind\": \"dimo\", \"api\": \"telemetry\" },\n  \"signal\": \"vehicle.speed\",\n  \"valueType\": \"number\",\n  \"unit\": \"mph\",\n  \"time\": { \"mode\": \"relative\", \"lookback\": \"30d\" },\n  \"aggregation\": { \"op\": \"p90\" }\n}\n```\n\n---\n\n## Best Practices\n\n### Composition\n\n1. Keep leaf policies focused on a single domain (driving behavior, financial health, identity)\n2. Use composition for cross-domain decisions (insurance eligibility = driving + vehicle + identity)\n3. Pin upstream policy versions to avoid unexpected behavior changes\n4. Test composed policies end-to-end — upstream policy changes can cascade\n\n### Rule Design\n\n1. Prefer explicit `and`/`or` trees over deeply nested structures — they're easier to debug\n2. Use `warn` severity for new rules you're evaluating before making them `fail`\n3. Name rules descriptively — `\"debt_to_income_ratio\"` not `\"rule_3\"`\n4. Test edge cases at threshold boundaries\n\n### Scoring\n\n1. Ensure contributions sum to a meaningful range relative to your baseline\n2. Use negative points sparingly — they make score interpretation harder\n3. Document what each score range means for your verifiers\n4. BAND labels should be intuitive to non-technical audiences\n\n---\n\n## Next Steps\n\n- [Policy Authoring Guide](/guides/policy-authoring) — Basics of creating a policy\n- [Policies](/concepts/policies) — Policy spec reference\n- [Proof Types](/concepts/proof-types) — Direct vs zkWitness input sources\n- [Extractors](/concepts/extractors) — Configuring data extraction for zkTLS inputs",
  },
  {
    uri: "bind://docs/guides/extractor-authoring",
    title: "Extractor Authoring Guide",
    content: "# Extractor Authoring Guide\n\nThis guide walks through creating a Bind extractor for a new data source.\n\n## Quick Start: Your First Extractor\n\n### 1. Identify the API\n\nFind the HTTPS endpoint that returns the data you need:\n\n```\nAPI: GET https://api.coinbase.com/v2/user\nResponse:\n{\n  \"data\": {\n    \"id\": \"abc123\",\n    \"country\": { \"code\": \"US\" },\n    \"tiers\": { \"completed_description\": \"Level 3\" }\n  }\n}\n```\n\n### 2. Create the Extractor\n\n```bash\nPOST /api/orgs/:orgId/extractors\n```\n\n```json\n{\n  \"slug\": \"coinbase-user\",\n  \"domain\": \"api.coinbase.com\",\n  \"pathPattern\": \"/v2/user\",\n  \"method\": \"GET\",\n  \"claimsSchema\": [\n    {\n      \"name\": \"userId\",\n      \"path\": \"$.data.id\",\n      \"type\": \"string\",\n      \"required\": true\n    },\n    {\n      \"name\": \"country\",\n      \"path\": \"$.data.country.code\",\n      \"type\": \"string\",\n      \"required\": true\n    },\n    {\n      \"name\": \"verificationLevel\",\n      \"path\": \"$.data.tiers.completed_description\",\n      \"type\": \"string\",\n      \"required\": false\n    }\n  ],\n  \"zktlsEnabled\": true,\n  \"requiresOAuth\": true,\n  \"oauthProvider\": \"coinbase\",\n  \"visibility\": \"private\"\n}\n```\n\n### 3. Test the Extractor\n\nCreate a zkTLS session:\n\n```bash\nPOST /api/orgs/:orgId/zktls/sessions\n```\n\n```json\n{\n  \"extractorId\": \"ext_abc123\",\n  \"extractorVersion\": \"1.0.0\"\n}\n```\n\nResponse:\n```json\n{\n  \"sessionId\": \"sess_xyz789\",\n  \"proxyUrl\": \"https://zkproxy.bind.dev/sess_xyz789\",\n  \"expiresAt\": \"2026-01-27T10:05:00Z\"\n}\n```\n\n### 4. Use in a Policy\n\nReference the extractor in your policy inputs:\n\n```json\n{\n  \"inputs\": [\n    {\n      \"name\": \"userCountry\",\n      \"source\": {\n        \"type\": \"extractor\",\n        \"extractorId\": \"coinbase-user\",\n        \"claim\": \"country\"\n      }\n    }\n  ]\n}\n```\n\n---\n\n## JSONPath Reference\n\n### Basic Paths\n\n| Expression | Extracts |\n|------------|----------|\n| `$.data.id` | `response.data.id` |\n| `$.user.name` | `response.user.name` |\n| `$.items[0]` | First item in array |\n| `$.items[-1]` | Last item in array |\n\n### Nested Objects\n\n```json\n// Response\n{ \"data\": { \"user\": { \"profile\": { \"email\": \"user@example.com\" } } } }\n\n// Path: $.data.user.profile.email\n// Result: \"user@example.com\"\n```\n\n### Arrays\n\n```json\n// Response\n{\n  \"accounts\": [\n    { \"currency\": \"USD\", \"balance\": 1000 },\n    { \"currency\": \"EUR\", \"balance\": 500 }\n  ]\n}\n\n// $.accounts[0].balance -> 1000\n// $.accounts[*].currency -> [\"USD\", \"EUR\"]\n// $.accounts[?(@.currency==\"USD\")].balance -> 1000\n```\n\n---\n\n## OAuth Configuration\n\nFor APIs requiring authentication:\n\n```json\n{\n  \"requiresOAuth\": true,\n  \"oauthProvider\": \"coinbase\"\n}\n```\n\n### Supported Providers\n\n| Provider | Domain | Notes |\n|----------|--------|-------|\n| `coinbase` | api.coinbase.com | User data, accounts |\n| `stripe` | api.stripe.com | Payment data |\n| `google` | *.googleapis.com | Various Google APIs |\n| `dimo` | api.dimo.zone | Vehicle telematics |\n\n### OAuth Flow\n\n1. User initiates OAuth in the dashboard or SDK\n2. User authenticates with the provider\n3. Bind receives authorization (never stores credentials)\n4. zkTLS witness uses the session to make API calls\n5. Credentials are discarded after session expires (5 min TTL)\n\n---\n\n## Path Patterns\n\n### Static Paths\n\n```json\n{ \"pathPattern\": \"/v2/user\" }\n```\n\n### Wildcard Paths\n\n```json\n{ \"pathPattern\": \"/v2/accounts/*/transactions\" }\n```\n\nMatches `/v2/accounts/abc123/transactions`, `/v2/accounts/def456/transactions`, etc.\n\n---\n\n## Versioning\n\n### Creating Versions\n\n```bash\nPOST /api/orgs/:orgId/extractors/:id/versions\n```\n\n```json\n{\n  \"version\": \"1.1.0\",\n  \"changelog\": \"Added verificationLevel claim\",\n  \"claimsSchema\": [...]\n}\n```\n\n### Version Pinning in Policies\n\n```json\n{\n  \"source\": {\n    \"type\": \"extractor\",\n    \"extractorId\": \"coinbase-user\",\n    \"extractorVersion\": \"1.0.0\"\n  }\n}\n```\n\nWithout pinning, policies use the latest version — risky for production.\n\n---\n\n## Testing\n\n### Dashboard Testing\n\nIn the dashboard, go to **Extractors > Your Extractor > Test** to paste a sample API response and see extracted claims in real-time.\n\n### API Testing\n\n```bash\nPOST /api/orgs/:orgId/extractors/:id/test\n```\n\n```json\n{\n  \"sampleResponse\": {\n    \"data\": {\n      \"id\": \"abc123\",\n      \"country\": { \"code\": \"US\" }\n    }\n  }\n}\n```\n\nResponse:\n```json\n{\n  \"claims\": { \"userId\": \"abc123\", \"country\": \"US\" },\n  \"errors\": []\n}\n```\n\n### Test Cases to Cover\n\n1. Happy path with all fields present\n2. Optional fields missing\n3. Required fields missing (should fail)\n4. Type mismatches\n5. Empty arrays\n6. Null values\n\n---\n\n## Real-World Examples\n\n### DIMO Telematics\n\n```json\n{\n  \"slug\": \"dimo-telematics\",\n  \"domain\": \"api.dimo.zone\",\n  \"pathPattern\": \"/v1/vehicles/*/stats\",\n  \"method\": \"GET\",\n  \"claimsSchema\": [\n    { \"name\": \"vehicleId\", \"path\": \"$.vehicleId\", \"type\": \"string\", \"required\": true },\n    { \"name\": \"totalMiles\", \"path\": \"$.stats.odometer\", \"type\": \"number\", \"required\": true },\n    { \"name\": \"hardBrakingPercentage\", \"path\": \"$.stats.hardBrakingRate\", \"type\": \"number\", \"required\": true },\n    { \"name\": \"averageSpeed\", \"path\": \"$.stats.avgSpeed\", \"type\": \"number\", \"required\": false }\n  ],\n  \"zktlsEnabled\": true,\n  \"requiresOAuth\": true,\n  \"oauthProvider\": \"dimo\",\n  \"visibility\": \"public\"\n}\n```\n\n### Stripe Customer\n\n```json\n{\n  \"slug\": \"stripe-customer\",\n  \"domain\": \"api.stripe.com\",\n  \"pathPattern\": \"/v1/customers/*\",\n  \"method\": \"GET\",\n  \"claimsSchema\": [\n    { \"name\": \"customerId\", \"path\": \"$.id\", \"type\": \"string\", \"required\": true },\n    { \"name\": \"email\", \"path\": \"$.email\", \"type\": \"string\", \"required\": true },\n    { \"name\": \"hasDefaultPayment\", \"path\": \"$.invoice_settings.default_payment_method\", \"type\": \"boolean\", \"required\": false }\n  ],\n  \"zktlsEnabled\": true,\n  \"requiresOAuth\": true,\n  \"oauthProvider\": \"stripe\",\n  \"visibility\": \"private\"\n}\n```\n\n---\n\n## Best Practices\n\n### API Selection\n1. Use stable API versions\n2. Prefer REST over GraphQL\n3. Check rate limits\n4. Verify HTTPS support\n\n### Claims Design\n1. Extract only what you need\n2. Use meaningful names\n3. Prefer primitives (string/number/boolean)\n4. Mark optional fields correctly\n\n### JSONPath\n1. Be specific — `$.data.user.id` not `$..id`\n2. Handle arrays carefully\n3. Test with real responses\n4. Consider null vs. missing\n\n### Security\n1. Never log credentials\n2. Validate domains carefully\n3. Review before publishing (permanent)\n4. Use path wildcards sparingly\n\n---\n\n## Troubleshooting\n\n| Problem | Common Causes | Fix |\n|---------|--------------|-----|\n| \"Claim not found\" | JSONPath typo, API response changed | Test with actual API response |\n| \"Invalid domain\" | Domain includes protocol or path | Use just the host: `api.example.com` |\n| \"OAuth provider not supported\" | Provider not integrated, typo | Check supported providers |\n| \"Attestation expired\" | Session TTL exceeded (5 min) | Create new session |",
  },
  {
    uri: "bind://docs/guides/notifications",
    title: "Notifications",
    content: "# Notifications\n\nBind delivers real-time notifications for key events in your organization — prove job completions, credential operations, shared proofs, team changes, and usage alerts. Notifications appear in the dashboard bell icon and can optionally be delivered by email.\n\n## Notification Channels\n\n| Channel | Description |\n|---------|-------------|\n| **In-app** | Bell icon in the dashboard header with unread count badge and dropdown list |\n| **Email** | Per-event emails sent to the user's registered address |\n\nBoth channels can be independently toggled per notification category.\n\n## Notification Categories\n\n| Category | Events |\n|----------|--------|\n| **Job Completions** | Prove jobs and circuit compilation jobs that complete successfully |\n| **Job Failures** | Prove jobs and circuit compilation jobs that fail |\n| **Team Events** | New members joining your organization, invite acceptances |\n| **Credential Events** | Credentials issued, verified cross-chain, or revoked |\n| **Shared Proofs** | Proofs shared with your organization by other orgs |\n| **System Alerts** | Usage threshold warnings (80%, 100%, 120% of monthly limits) |\n\n## Using the Notification Bell\n\nThe notification bell appears in the top-right corner of the dashboard header. A red badge shows the count of unread notifications.\n\nClick the bell to open the notification dropdown:\n\n- **Unread notifications** have a highlighted background and a blue dot\n- Click a notification to mark it as read and navigate to the relevant page\n- Click **Mark all read** to clear all unread indicators\n- Click the **gear icon** to open notification preferences\n\nThe bell polls for new notifications every 30 seconds.\n\n## Configuring Preferences\n\nNavigate to **Settings > Notifications** or click the gear icon in the notification dropdown.\n\nThe preferences page shows a grid of categories vs. channels. Toggle each combination on or off:\n\n| Category | In-App | Email |\n|----------|--------|-------|\n| Job Completions | On by default | On by default |\n| Job Failures | On by default | On by default |\n| Team Events | On by default | Off by default |\n| Credential Events | On by default | Off by default |\n| Shared Proofs | On by default | Off by default |\n| System Alerts | On by default | On by default |\n\nPreferences are per-user — each team member controls their own notification settings.\n\n:::info\nEmail notifications require the platform to be configured with AWS SES. If email delivery is not configured, in-app notifications still work normally.\n:::\n\n## Notification Lifecycle\n\n- Notifications expire automatically after **90 days**\n- Read status is tracked per-user, even for org-wide notifications\n- Dismissed or expired notifications are cleaned up automatically\n\n## Programmatic Access\n\nYou can also manage notifications via the API. See the [Notifications API reference](/api/notifications) for full endpoint documentation.\n\n### Quick Example: Fetch Unread Count\n\n```bash\ncurl https://api.bindprotocol.com/api/notifications/unread-count \\\n  -H \"Authorization: Bearer <token>\"\n```\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"count\": 3\n  }\n}\n```\n\n---\n\n## Next Steps\n\n- [Notifications API](/api/notifications) — Full endpoint reference\n- [Webhooks](/guides/webhooks) — HTTP callbacks for programmatic event handling\n- [Organization Management](/guides/org-management) — Team and settings administration",
  },
  {
    uri: "bind://docs/guides/org-management",
    title: "Organization Management",
    content: "# Organization Management\n\nThis guide covers day-to-day administration of your Bind organization — inviting team members, assigning roles, managing API keys, and configuring org settings.\n\n:::info\nOrganization management endpoints require **JWT authentication**. You can also manage these in the dashboard under **Settings**.\n:::\n\n## User Roles\n\nEvery user in an organization has one of three roles:\n\n| Role | Description | Capabilities |\n|------|-------------|-------------|\n| `admin` | Full system access | All operations, user management, org settings |\n| `org_manager` | Organization management | Manage users, API keys, signing keys, webhooks, policies, extractors |\n| `org_user` | Standard access | Read/write policies, extractors, prove jobs — no user management |\n\nRoles are assigned when inviting a user and can be changed by an `admin` or `org_manager`.\n\n## Inviting Users\n\nInvite team members by generating an invite token. The invite can optionally include the user's email for tracking.\n\n### Create an Invite\n\n```bash\ncurl -X POST https://api.bindprotocol.com/api/invites \\\n  -H \"Authorization: Bearer <token>\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"alice@example.com\",\n    \"role\": \"org_user\",\n    \"expiresInDays\": 7\n  }'\n```\n\n| Field | Type | Required | Default | Description |\n|-------|------|----------|---------|-------------|\n| `email` | string | No | — | Invitee's email (for tracking, not required) |\n| `role` | string | Yes | — | `admin`, `org_manager`, or `org_user` |\n| `expiresInDays` | number | No | 7 | Invite validity (1–30 days) |\n\nThe response includes an `inviteToken` that you share with the user.\n\n### Accept an Invite\n\nThe invitee signs up using their invite token:\n\n```bash\ncurl -X POST https://api.bindprotocol.com/api/invites/accept \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"token\": \"<inviteToken>\",\n    \"email\": \"alice@example.com\",\n    \"password\": \"securePassword123\",\n    \"name\": \"Alice\"\n  }'\n```\n\nAccepting an invite creates the user's account and automatically logs them in. The response includes JWT tokens for immediate access.\n\n### List Pending Invites\n\n```bash\ncurl https://api.bindprotocol.com/api/invites \\\n  -H \"Authorization: Bearer <token>\"\n```\n\n### Revoke an Invite\n\n```bash\ncurl -X DELETE https://api.bindprotocol.com/api/invites/:inviteId \\\n  -H \"Authorization: Bearer <token>\"\n```\n\n---\n\n## Managing Team Members\n\n### List Team Members\n\n```bash\ncurl https://api.bindprotocol.com/api/invites/team \\\n  -H \"Authorization: Bearer <token>\"\n```\n\nReturns all active users with their roles, email addresses, and last login timestamps.\n\n### Remove a User\n\n```bash\ncurl -X DELETE https://api.bindprotocol.com/api/invites/team/:userId \\\n  -H \"Authorization: Bearer <token>\"\n```\n\n:::warning\nRemoving a user **permanently deletes** their account. This action cannot be undone. The user's authentication credentials are removed and any resources they created (policies, extractors, etc.) will have their creator reference cleared.\n:::\n\n### User Limits by Tier\n\n| Tier | Max Users |\n|------|-----------|\n| Basic | 3 |\n| Premium | Unlimited |\n| Scale | Unlimited |\n| Verifier | 10 |\n| Enterprise | Unlimited |\n\nIf you've reached your tier's user limit, you'll receive a `403` error when creating new invites. Upgrade to Premium or higher for unlimited users.\n\n---\n\n## API Key Management\n\nAPI keys are used for programmatic access to runtime endpoints (prove, verify, share). See [Authentication](/api/authentication) for details on key format and usage.\n\n### Create an API Key\n\n```bash\ncurl -X POST https://api.bindprotocol.com/api/orgs/:orgId/api-keys \\\n  -H \"Authorization: Bearer <token>\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"production-key\"\n  }'\n```\n\nThe secret is returned **only once** in the response. Store it securely.\n\n### Revoke an API Key\n\n```bash\ncurl -X POST https://api.bindprotocol.com/api/orgs/:orgId/api-keys/:keyId/revoke \\\n  -H \"Authorization: Bearer <token>\"\n```\n\nRevocation is immediate — any requests using the key will fail with `401`.\n\n### API Key Limits by Tier\n\n| Tier | Max API Keys |\n|------|-------------|\n| Basic | 1 |\n| Premium | Unlimited |\n| Scale | Unlimited |\n| Verifier | 5 |\n| Enterprise | Unlimited |\n\n---\n\n## Organization Settings\n\n### View Org Details\n\n```bash\ncurl https://api.bindprotocol.com/api/auth/org \\\n  -H \"Authorization: Bearer <token>\"\n```\n\nReturns your organization's name, tier, and settings.\n\n### Update Settings\n\n```bash\ncurl -X PATCH https://api.bindprotocol.com/api/auth/org \\\n  -H \"Authorization: Bearer <token>\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"discoverable\": true\n  }'\n```\n\n| Setting | Type | Description |\n|---------|------|-------------|\n| `discoverable` | boolean | Whether your org appears in the marketplace and can receive shared proofs |\n\n---\n\n## SSO/SAML Authentication\n\nSingle sign-on via SAML is available on the **Enterprise** tier. Enterprise SSO allows your team to authenticate using your existing identity provider (Okta, Azure AD, Google Workspace, etc.) instead of email/password credentials.\n\nContact [sales@bindprotocol.com](mailto:sales@bindprotocol.com) to configure SSO for your organization.\n\n---\n\n## Next Steps\n\n- [Organizations and Tiers](/concepts/organizations) — Tier permissions and resource limits\n- [Signing Keys](/concepts/signing-keys) — Managing credential signing keys\n- [Authentication](/api/authentication) — API key format and JWT token flow",
  },
  {
    uri: "bind://docs/guides/policy-authoring",
    title: "Policy Authoring Guide",
    content: "# Policy Authoring Guide\n\nThis guide walks through creating a Bind policy from scratch — from defining what you're proving to generating a circuit and testing it.\n\n:::info Tier Limits\nPolicy complexity is constrained by your organization's tier. Basic-tier policies are limited to **3 inputs**, **5 rules**, **2 outputs**, expression depth of **3**, and can only use `dimo`, `api`, and `static` source kinds. Premium and Enterprise tiers have higher or unlimited limits and access to all source kinds including `composed` and `zktls`. See [Organizations and Tiers](/concepts/organizations#policy-complexity-limits) for the full breakdown.\n:::\n\n## Quick Start: Your First Policy\n\n### 1. Define What You're Proving\n\nStart with the verifier's question:\n\n```\nVerifier question: \"Is this a safe driver?\"\nAnswer format: PASS or FAIL\nCriteria: >10,000 miles driven AND <5% hard braking events\n```\n\n### 2. Create the Policy via API\n\n```bash\nPOST /api/orgs/:orgId/policies\n```\n\n```json\n{\n  \"metadata\": {\n    \"title\": \"Safe Driver Verification\",\n    \"description\": \"Verifies driving behavior meets safety thresholds\",\n    \"namespace\": \"dimo\"\n  },\n  \"subject\": {\n    \"type\": \"vehicle\",\n    \"identifier\": \"vehicleId\"\n  },\n  \"outputs\": [\n    {\n      \"name\": \"safeDriver\",\n      \"type\": \"PASS_FAIL\",\n      \"description\": \"Whether the driver meets safety criteria\"\n    }\n  ],\n  \"validity\": {\n    \"duration\": \"P90D\",\n    \"renewable\": true\n  },\n  \"inputs\": [\n    {\n      \"name\": \"milesDriven\",\n      \"source\": {\n        \"type\": \"extractor\",\n        \"extractorId\": \"dimo-telematics\",\n        \"claim\": \"totalMiles\"\n      }\n    },\n    {\n      \"name\": \"hardBrakeRate\",\n      \"source\": {\n        \"type\": \"extractor\",\n        \"extractorId\": \"dimo-telematics\",\n        \"claim\": \"hardBrakingPercentage\"\n      }\n    }\n  ],\n  \"rules\": [\n    {\n      \"id\": \"mileage_check\",\n      \"severity\": \"fail\",\n      \"assertion\": {\n        \"type\": \"cmp\",\n        \"operator\": \">=\",\n        \"left\": { \"type\": \"ref\", \"path\": \"inputs.milesDriven\" },\n        \"right\": { \"type\": \"const\", \"value\": 10000 }\n      }\n    },\n    {\n      \"id\": \"braking_check\",\n      \"severity\": \"fail\",\n      \"assertion\": {\n        \"type\": \"cmp\",\n        \"operator\": \"<\",\n        \"left\": { \"type\": \"ref\", \"path\": \"inputs.hardBrakeRate\" },\n        \"right\": { \"type\": \"const\", \"value\": 5 }\n      }\n    }\n  ],\n  \"evaluation\": {\n    \"type\": \"pass_fail\",\n    \"output\": \"safeDriver\"\n  }\n}\n```\n\n### 3. Generate the Circuit\n\n```bash\nPOST /api/orgs/:orgId/policies/:policyId/generate-circuit\n```\n\nBind automatically generates the cryptographic circuit, compiles it, and prepares it for proof generation.\n\n### 4. Test the Policy\n\nSubmit a prove job with test data:\n\n```bash\nPOST /api/orgs/:orgId/prove\n```\n\n```json\n{\n  \"policyId\": \"pol_abc123\",\n  \"inputs\": {\n    \"milesDriven\": 15000,\n    \"hardBrakeRate\": 3.2\n  }\n}\n```\n\n---\n\n## Policy Spec Reference\n\n### Metadata\n\n```typescript\nmetadata: {\n  title: string;           // Human-readable name\n  description: string;     // What this policy proves\n  namespace: string;       // Grouping (e.g., \"dimo\", \"insurance\")\n  authors: string[];       // Optional\n}\n```\n\n### Subject\n\n```typescript\nsubject: {\n  type: \"vehicle\" | \"device\" | \"user\" | \"organization\";\n  identifier: string;      // Field that identifies the subject\n}\n```\n\n### Outputs\n\n| Type | Use Case | Example Output |\n|------|----------|----------------|\n| `PASS_FAIL` | Binary decisions | `{ \"safeDriver\": true }` |\n| `SCORE` | Numeric ratings | `{ \"riskScore\": 85 }` |\n| `BAND` | Categorical tiers | `{ \"riskTier\": \"LOW\" }` |\n| `CONST` | Fixed values | `{ \"policyVersion\": \"1.0\" }` |\n\n```typescript\noutputs: [\n  {\n    name: string;\n    type: \"PASS_FAIL\" | \"SCORE\" | \"BAND\" | \"CONST\";\n    description: string;\n\n    // For BAND type:\n    bands?: {\n      thresholds: number[];  // e.g., [30, 70]\n      labels: string[];      // e.g., [\"HIGH\", \"MEDIUM\", \"LOW\"]\n    };\n\n    // For CONST type:\n    value?: any;\n  }\n]\n```\n\n### Validity\n\n```typescript\nvalidity: {\n  duration: string;        // ISO 8601 duration (e.g., \"P90D\" = 90 days)\n  renewable: boolean;\n}\n```\n\n### Disclosure\n\n```typescript\ndisclosure: {\n  level: \"full\" | \"partial\" | \"minimal\";\n  redactedFields: string[];\n}\n```\n\n---\n\n## Input Sources\n\n### From zkTLS Extractors (Primary)\n\n```typescript\n{\n  name: \"accountBalance\",\n  source: {\n    type: \"extractor\",\n    extractorId: \"coinbase-accounts\",\n    extractorVersion: \"1.0.0\",     // Pin to version for production\n    claim: \"usdBalance\"\n  }\n}\n```\n\n### Direct Input (Testing)\n\n```typescript\n{\n  name: \"userAge\",\n  source: {\n    type: \"direct\",\n    inputType: \"number\"\n  }\n}\n```\n\n### Aggregations\n\n```typescript\n{\n  name: \"avgSpeed90Days\",\n  source: {\n    type: \"aggregation\",\n    function: \"avg\",              // min, max, avg, sum, percentile\n    over: \"inputs.dailySpeeds\",\n    window: \"P90D\"\n  }\n}\n```\n\n---\n\n## Rule Expressions\n\n### Operators\n\n**Comparison:** `>`, `>=`, `<`, `<=`, `==`, `!=`\n\n**Logical:** `and`, `or`, `not`\n\n**Arithmetic:** `+`, `-`, `*`, `/`\n\n### Examples\n\n**Simple comparison:**\n```json\n{\n  \"type\": \"cmp\",\n  \"operator\": \">=\",\n  \"left\": { \"type\": \"ref\", \"path\": \"inputs.milesDriven\" },\n  \"right\": { \"type\": \"const\", \"value\": 10000 }\n}\n```\n\n**Combined conditions:**\n```json\n{\n  \"type\": \"and\",\n  \"children\": [\n    {\n      \"type\": \"cmp\",\n      \"operator\": \">=\",\n      \"left\": { \"type\": \"ref\", \"path\": \"inputs.milesDriven\" },\n      \"right\": { \"type\": \"const\", \"value\": 10000 }\n    },\n    {\n      \"type\": \"cmp\",\n      \"operator\": \"<\",\n      \"left\": { \"type\": \"ref\", \"path\": \"inputs.hardBrakeRate\" },\n      \"right\": { \"type\": \"const\", \"value\": 5 }\n    }\n  ]\n}\n```\n\n**Computed value:**\n```json\n{\n  \"type\": \"cmp\",\n  \"operator\": \"<\",\n  \"left\": {\n    \"type\": \"op\",\n    \"operator\": \"/\",\n    \"left\": { \"type\": \"ref\", \"path\": \"inputs.hardBrakeEvents\" },\n    \"right\": { \"type\": \"ref\", \"path\": \"inputs.totalEvents\" }\n  },\n  \"right\": { \"type\": \"const\", \"value\": 0.05 }\n}\n```\n\n---\n\n## Evaluation Logic\n\n### PASS_FAIL\n\nAll rules with `severity: \"fail\"` must pass:\n\n```typescript\nevaluation: {\n  type: \"pass_fail\",\n  output: \"safeDriver\"\n}\n\nrules: [\n  { id: \"rule1\", severity: \"fail\", ... },  // Must pass\n  { id: \"rule2\", severity: \"warn\", ... },  // Logged but doesn't fail\n]\n```\n\n### SCORE\n\nRules contribute weighted points:\n\n```typescript\nevaluation: {\n  type: \"score\",\n  output: \"riskScore\",\n  maxScore: 100,\n  contributions: [\n    { rule: \"mileage_check\", weight: 30 },\n    { rule: \"braking_check\", weight: 40 },\n    { rule: \"speeding_check\", weight: 30 }\n  ]\n}\n```\n\n### BAND\n\nScore converted to categorical tiers:\n\n```typescript\nevaluation: {\n  type: \"band\",\n  output: \"riskTier\",\n  scoreOutput: \"riskScore\",\n  thresholds: [30, 70],\n  labels: [\"HIGH\", \"MEDIUM\", \"LOW\"]  // <30 = HIGH, 30-70 = MEDIUM, >70 = LOW\n}\n```\n\n---\n\n## Visual Policy Builder\n\nThe dashboard includes a drag-and-drop editor for building policies without writing JSON.\n\n### Node Types\n\n| Node | Purpose |\n|------|---------|\n| **Input** | Define data source signal |\n| **Constant** | Fixed numeric/boolean value |\n| **Reference** | Reference to input value |\n| **Comparison** | Compare two values |\n| **Operator** | Arithmetic operations |\n| **Rule** | Named assertion with severity |\n| **Evaluation** | Combine rules into output |\n| **Output** | Final policy output |\n\n### Templates\n\nPre-built patterns available:\n- **Safe Driver** — Mileage + braking behavior\n- **KYC Verification** — Identity + country checks\n- **Account Balance** — Minimum balance threshold\n- **Age Verification** — Date of birth check\n\n---\n\n## Best Practices\n\n### Design\n1. Start with the verifier's question\n2. Minimize inputs — only request data you need\n3. Use appropriate output types\n4. Set reasonable validity periods\n\n### Security\n1. Keep private spec private\n2. Use extractors, not direct inputs, for production\n3. Pin extractor versions\n4. Test edge cases at thresholds\n\n### Naming\n1. Descriptive titles — \"Safe Driver Verification\" not \"Policy 1\"\n2. Consistent namespaces\n3. Meaningful rule IDs — \"mileage_check\" not \"rule1\"\n\n---\n\n## Troubleshooting\n\n| Problem | Common Causes | Fix |\n|---------|--------------|-----|\n| Circuit generation fails | Type mismatch, missing input, invalid operator | Check error message, review input types |\n| Proof generation fails | Input out of range, missing inputs, expired attestation | Verify input values match expected types |\n| Credential not issued | All rules failed, score below threshold | Review evaluation logic and rule severities |",
  },
  {
    uri: "bind://docs/guides/proof-generation",
    title: "Proof Generation",
    content: "# Proof Generation\n\nThis guide covers the end-to-end flow of generating zero-knowledge proofs with Bind.\n\n## How Proofs Work\n\n```mermaid\nflowchart LR\n    A[\"Submit Job\\n(API/SDK)\"] --> B[Generate ZK Proof]\n    B --> C[\"Verify\\n(optional)\"]\n    C --> D[Credential Available]\n```\n\n1. You submit a prove job with a policy ID and inputs\n2. Bind generates a zero-knowledge proof that the inputs satisfy the policy\n3. Optionally, the proof is submitted to zkVerify for on-chain verification\n4. Proof artifacts and credential are available for download or sharing\n\n## Submitting a Prove Job\n\n### Via SDK\n\n```typescript\nimport { BindClient } from '@bind-protocol/sdk';\n\nconst client = new BindClient({ apiKey: 'idbr_your_key' });\n\nconst { jobId } = await client.submitProveJob('bind.dimo.riskband.v0_1_0', {\n  mileage_90d: '2500',\n  data_points: '450',\n  speed_max: '72',\n});\n```\n\n### Via API\n\n```bash\ncurl -X POST https://api.bindprotocol.com/api/prove \\\n  -H \"X-API-Key: idbr_your_key\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"circuitId\": \"bind.dimo.riskband.v0_1_0\",\n    \"inputs\": {\n      \"mileage_90d\": \"2500\",\n      \"data_points\": \"450\",\n      \"speed_max\": \"72\"\n    },\n    \"verificationMode\": \"zkverify\"\n  }'\n```\n\n## Verification Modes\n\n| Mode | Description | Cost |\n|------|-------------|------|\n| `zkverify` | Proof submitted to zkVerify network for on-chain verification | Higher |\n| `self_verify` | Proof artifacts returned for self-verification | Lower |\n\n## Polling for Completion\n\nProof generation is asynchronous. Poll for the result.\n\n### SDK (recommended)\n\n```typescript\nconst job = await client.waitForProveJob(jobId, {\n  onProgress: (j) => console.log(`Status: ${j.status}`),\n});\n\nif (job.status === 'completed') {\n  console.log('Attestation ID:', job.attestationId);\n}\n```\n\n### API\n\n```bash\ncurl https://api.bindprotocol.com/api/prove/job_abc123 \\\n  -H \"X-API-Key: idbr_your_key\"\n```\n\n## Job Statuses\n\n| Status | Description |\n|--------|-------------|\n| `pending` | Job queued, waiting to be processed |\n| `processing` | Proof is being generated |\n| `completed` | Proof generated successfully |\n| `failed` | Proof generation failed (check `error` field) |\n\n## Completed Job Response\n\n```json\n{\n  \"jobId\": \"job_abc123\",\n  \"status\": \"completed\",\n  \"circuitId\": \"bind.dimo.riskband.v0_1_0\",\n  \"verificationMode\": \"zkverify\",\n  \"attestationId\": \"att_xyz789\",\n  \"zkVerifyTxHash\": \"0x...\"\n}\n```\n\nFor `self_verify` mode, the response includes `downloadUrls` with pre-signed URLs to download proof artifacts (proof, verification key, public inputs).\n\n## Sharing Proofs\n\nAfter generating a proof, share it with a verifier organization:\n\n```bash\ncurl -X POST https://api.bindprotocol.com/api/shared-proofs \\\n  -H \"X-API-Key: idbr_your_key\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"proveJobId\": \"job_abc123\",\n    \"verifierOrgId\": \"org_verifier\",\n    \"expiresAt\": \"2026-04-01T00:00:00Z\",\n    \"note\": \"Q1 2026 risk assessment\"\n  }'\n```\n\n## Usage Limits\n\n- Prove jobs count toward your tier's monthly operation limit\n- Usage is recorded when the job is successfully submitted\n- Check your current usage in the dashboard on the **Home** page or via `GET /api/tier/usage`\n\n## Webhooks\n\nSet up webhooks to get notified when prove jobs complete instead of polling:\n\n```json\n{\n  \"url\": \"https://your-app.com/webhooks/bind\",\n  \"events\": [\"prove.completed\", \"prove.failed\"]\n}\n```\n\nSee the [Webhooks Guide](/guides/webhooks) for setup details.",
  },
  {
    uri: "bind://docs/guides/webhooks",
    title: "Webhooks",
    content: "# Webhooks\n\nBind sends webhook events when key actions occur in your organization. Use webhooks to get notified about proof completions, credential issuance, and more.\n\n## Setting Up a Webhook\n\n```bash\nPOST /api/webhooks\nAuthorization: Bearer <token>\nContent-Type: application/json\n\n{\n  \"url\": \"https://your-app.com/webhooks/bind\",\n  \"events\": [\"credential.issued\", \"credential.verified\", \"prove.completed\"],\n  \"name\": \"Production webhook\",\n  \"secret\": \"your-signing-secret\"\n}\n```\n\nThe response includes the webhook ID and the signing secret (only shown once on creation).\n\n## Verifying Webhook Signatures\n\nBind signs webhook payloads with HMAC-SHA256 using your webhook secret. Verify the signature to ensure the request is authentic:\n\n```typescript\nimport crypto from 'crypto';\n\nfunction verifyWebhook(payload: string, signature: string, secret: string): boolean {\n  const expected = crypto\n    .createHmac('sha256', secret)\n    .update(payload)\n    .digest('hex');\n  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expected));\n}\n```\n\n## Event Types\n\n| Event | Trigger |\n|-------|---------|\n| `credential.issued` | Credential successfully issued |\n| `credential.verified` | Credential verified |\n| `prove.completed` | Prove job completed successfully |\n| `prove.failed` | Prove job failed |\n\n## Managing Webhooks\n\n### List Webhooks\n\n```bash\nGET /api/webhooks\n```\n\n### Update a Webhook\n\n```bash\nPUT /api/webhooks/:id\n```\n\n### Delete a Webhook\n\n```bash\nDELETE /api/webhooks/:id\n```\n\n### Test a Webhook\n\nSend a test event to verify your endpoint is working:\n\n```bash\nPOST /api/webhooks/:id/test\nContent-Type: application/json\n\n{\n  \"event_type\": \"credential.issued\"\n}\n```\n\n### Rotate Secret\n\n```bash\nPOST /api/webhooks/:id/rotate-secret\n```\n\n## Delivery History\n\nCheck delivery status and debug failures:\n\n```bash\nGET /api/webhooks/deliveries?webhook_id=wh_abc123&status=failed\n```\n\n## Webhook Statistics\n\n```bash\nGET /api/webhooks/stats?days=30\n```\n\nReturns total deliveries, success/failure counts, and average response time.\n\n## Retry Policy\n\nFailed webhook deliveries are retried automatically with exponential backoff. Check the delivery history to see retry attempts and response codes.",
  },
  {
    uri: "bind://docs/intro",
    title: "Introduction",
    content: "# Bind Protocol\n\n**Privacy-preserving attestations for the data economy.**\n\nBind enables organizations to prove claims about data using zero-knowledge cryptography — without exposing the underlying information.\n\n## How It Works\n\n1. **Witness** data from any HTTPS API via zkTLS, without storing credentials or raw data\n2. **Apply policies** that transform witnessed data into business-relevant outputs (risk scores, pass/fail, bands)\n3. **Generate proofs** using zero-knowledge cryptography that the policy was evaluated correctly\n4. **Issue credentials** as W3C Verifiable Credentials that can be verified by anyone, anywhere\n\n## What This Enables\n\n- Insurance companies verify risk without seeing trip locations or sensor data\n- Lenders assess creditworthiness without accessing bank statements\n- Employers check credentials without storing license copies\n- Healthcare systems verify eligibility without centralizing patient records\n- Supply chains prove compliance without exposing supplier relationships\n\n## What Makes Bind Different\n\n| | Traditional Verification | Other Privacy Tech | Bind |\n|---|---|---|---|\n| **Trust model** | \"Trust me\" claims | DIY cryptography | Cryptographic proofs |\n| **Data exposure** | Full transparency required | Varies | Zero-knowledge by default |\n| **Integration** | Custom per source | Custom per source | Works with any HTTPS API |\n| **Output** | Proprietary formats | Custom formats | W3C Verifiable Credentials |\n| **Complexity** | Low | Very high | Managed by Bind |\n\n## Core Concepts\n\n| Concept | Description |\n|---------|-------------|\n| [**Policy**](/concepts/policies) | Declarative spec defining what to prove about a subject |\n| [**Extractor**](/concepts/extractors) | Config for pulling data from an HTTPS API via zkTLS |\n| [**zkTLS**](/concepts/zktls) | Cryptographic witnessing of HTTPS API traffic |\n| [**Credential**](/concepts/credentials) | W3C Verifiable Credential issued after successful proof |\n| [**Marketplace**](/concepts/marketplace) | Public registry of reusable policies and extractors |\n\n## Next Steps\n\n- [**Quickstart**](/quickstart) — Get an API key and generate your first proof in minutes\n- [**API Reference**](/api/overview) — Full endpoint documentation\n- [**SDK**](/sdk/overview) — TypeScript SDK for integrating Bind into your application",
  },
  {
    uri: "bind://docs/mcp/overview",
    title: "MCP Server Overview",
    content: "# MCP Server\n\n:::caution Alpha\nMCP support is in alpha. Tools, server URLs, and configuration may change between releases.\n:::\n\nBind Protocol provides [Model Context Protocol](https://modelcontextprotocol.io/) (MCP) servers that give AI agents — Claude, Cursor, Windsurf, and others — direct access to credential verification tools and protocol documentation.\n\n## Architecture\n\nBind ships two MCP servers that work together:\n\n```mermaid\nflowchart LR\n    A[\"AI Agent\\n(Claude, Cursor, etc.)\"] -->|stdio| B[\"Local Server\\n@bind-protocol/mcp-server\"]\n    A -->|Streamable HTTP| C[\"Remote Server\\nmcp.bindprotocol.xyz\"]\n    B -->|\"JWKS fetch\"| D[\"Bind API\"]\n    C -->|\"cached fetch\"| D\n```\n\n| Server | Transport | What it does |\n|--------|-----------|-------------|\n| **Local** (`@bind-protocol/mcp-server`) | stdio via npx | Parses, verifies, and hashes VC-JWTs. Credential data never leaves your machine. |\n| **Remote** (`mcp.bindprotocol.xyz`) | Streamable HTTP | Resolves issuers, explains policies, checks revocation status. Serves protocol documentation. |\n\n### Why two servers?\n\nThis mirrors how crypto wallets work: the wallet is local, the chain is remote.\n\n- **Privacy** — Raw credentials stay on your machine. The local server handles parsing, signature verification, and hashing without sending credential data to any external service.\n- **Simple auth** — The remote server requires your Bind API key, passed via the `Authorization` header in your MCP client config. No server-side secrets to manage.\n- **Performance** — Public data (issuer keys, policies, docs) is served from Cloudflare's edge with caching. No round-trip to your machine needed.\n\n## Tools\n\nSix tools are available across the two servers:\n\n| Tool | Server | Description |\n|------|--------|-------------|\n| `bind_parse_credential` | Local | Decode a VC-JWT into header, payload, and signature |\n| `bind_verify_credential` | Local | Verify signature, check expiration, return claims |\n| `bind_hash_credential` | Local | Compute SHA-256 hash of a VC-JWT |\n| `bind_resolve_issuer` | Remote | Fetch an organization's public signing keys (JWKS) |\n| `bind_explain_policy` | Remote | Fetch a policy's public specification |\n| `bind_check_revocation` | Remote | Check revocation status by credential hash |\n\n## Documentation Resources\n\nThe remote server also exposes 43 pages of Bind Protocol documentation as MCP resources. AI agents can read these directly to understand the protocol without leaving their workflow.\n\n## Next Steps\n\n- [Setup Guide](/mcp/setup) — Configure both servers in your AI tool\n- [Tool Reference](/mcp/tools) — Detailed reference for all 6 tools\n- [Example Workflows](/mcp/workflows) — Common verification patterns",
  },
  {
    uri: "bind://docs/mcp/setup",
    title: "Setup",
    content: "# Setup\n\nAdd Bind's MCP servers to your AI tool in under a minute.\n\n## Prerequisites\n\n- **Node.js >= 18** (for the local server; npx handles installation automatically)\n- **Bind API key** — The remote server requires your Bind API key, passed via `Authorization: Bearer <key>` header. You can generate one at [app.bindprotocol.xyz](https://app.bindprotocol.xyz).\n\n## Claude Desktop / Claude Code\n\nAdd both servers to your MCP configuration:\n\n```json\n{\n  \"mcpServers\": {\n    \"bind\": {\n      \"command\": \"npx\",\n      \"args\": [\"@bind-protocol/mcp-server\"]\n    },\n    \"bind-remote\": {\n      \"type\": \"streamable-http\",\n      \"url\": \"https://mcp.bindprotocol.xyz/mcp\",\n      \"headers\": {\n        \"Authorization\": \"Bearer idbr_your_key_here\"\n      }\n    }\n  }\n}\n```\n\n**Claude Desktop:** Open **Settings > Developer > Edit Config** and paste the above.\n\n**Claude Code:** Add to `~/.claude/claude_desktop_config.json` or your project's `.mcp.json`.\n\n## Cursor\n\nAdd to your Cursor MCP settings (`.cursor/mcp.json` in your project root):\n\n```json\n{\n  \"mcpServers\": {\n    \"bind\": {\n      \"command\": \"npx\",\n      \"args\": [\"@bind-protocol/mcp-server\"]\n    },\n    \"bind-remote\": {\n      \"type\": \"streamable-http\",\n      \"url\": \"https://mcp.bindprotocol.xyz/mcp\",\n      \"headers\": {\n        \"Authorization\": \"Bearer idbr_your_key_here\"\n      }\n    }\n  }\n}\n```\n\n## Windsurf\n\nAdd to your Windsurf MCP settings:\n\n```json\n{\n  \"mcpServers\": {\n    \"bind\": {\n      \"command\": \"npx\",\n      \"args\": [\"@bind-protocol/mcp-server\"]\n    },\n    \"bind-remote\": {\n      \"type\": \"streamable-http\",\n      \"url\": \"https://mcp.bindprotocol.xyz/mcp\",\n      \"headers\": {\n        \"Authorization\": \"Bearer idbr_your_key_here\"\n      }\n    }\n  }\n}\n```\n\n## Verifying the Setup\n\nOnce configured, ask your AI agent:\n\n> \"What tools do you have from Bind Protocol?\"\n\nIt should list 6 tools (3 local, 3 remote) and have access to Bind documentation resources.\n\nYou can also test a specific tool:\n\n> \"Use bind_explain_policy to look up the policy `bind.dimo.riskband.v0_1_0`\"\n\n## Requirements\n\n- **Local server:** Node.js >= 18 (npx handles installation automatically)\n- **Remote server:** A Bind API key, passed via the `Authorization` header in your MCP config\n- **API key:** Required for the remote server. Generate one at [app.bindprotocol.xyz](https://app.bindprotocol.xyz)\n\n## Optional: Local Server Environment\n\nThe local server works out of the box, but you can override the API URL if needed:\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `BIND_API_URL` | `https://api.bindprotocol.xyz` | Base URL for public API calls (JWKS fetches during verification) |\n| `LOG_LEVEL` | `info` | Logging verbosity (`debug`, `info`, `warn`, `error`) |\n\nSet these in your shell environment before launching the AI tool, or in the MCP config:\n\n```json\n{\n  \"mcpServers\": {\n    \"bind\": {\n      \"command\": \"npx\",\n      \"args\": [\"@bind-protocol/mcp-server\"],\n      \"env\": {\n        \"LOG_LEVEL\": \"debug\"\n      }\n    }\n  }\n}\n```\n\n## Next Steps\n\n- [Tool Reference](/mcp/tools) — Detailed reference for all 6 tools\n- [Example Workflows](/mcp/workflows) — Common verification patterns",
  },
  {
    uri: "bind://docs/mcp/tools",
    title: "Tool Reference",
    content: "# Tool Reference\n\nDetailed reference for all 14 MCP tools provided by Bind Protocol.\n\n## Local Tools\n\nThese tools run on your machine via stdio. Credential data never leaves your environment.\n\n### bind_parse_credential\n\nDecode a VC-JWT into its header, payload, and signature without verifying the signature. Use this to inspect a credential before verification.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `jwt` | string | Yes | The VC-JWT string to parse |\n\n**Returns:** JSON object with `header`, `payload`, and `signature` (base64url-encoded).\n\n**Example prompt:**\n\n> \"Parse this credential: eyJhbGciOiJFUzI1NiIs...\"\n\n---\n\n### bind_verify_credential\n\nVerify a VC-JWT end-to-end: parse the JWT, fetch the issuer's JWKS, verify the ES256 signature, and check expiration. Does **not** check revocation — use `bind_check_revocation` separately.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `jwt` | string | Yes | The VC-JWT string to verify |\n\n**Returns:** On success: `{ valid: true, issuer, kid, claims }`. On failure: `{ valid: false, error }`.\n\n**What it checks:**\n\n1. JWT structure (3 dot-separated parts)\n2. Algorithm is ES256\n3. `kid` present in header\n4. Issuer's JWKS fetched from `GET /api/orgs/:orgId/.well-known/jwks.json`\n5. Matching public key found\n6. ECDSA P-256 signature valid\n7. `vc.validUntil` and `exp` not expired\n\n**Example prompt:**\n\n> \"Verify this credential and tell me who issued it: eyJhbGciOiJFUzI1NiIs...\"\n\n---\n\n### bind_hash_credential\n\nCompute the SHA-256 hash of a VC-JWT. The resulting hash can be passed to `bind_check_revocation` to check revocation status.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `jwt` | string | Yes | The VC-JWT string to hash |\n\n**Returns:** `{ hash: \"0x...\" }` — hex-encoded SHA-256 hash with `0x` prefix.\n\n**Example prompt:**\n\n> \"Hash this credential so I can check its revocation status: eyJhbGciOiJFUzI1NiIs...\"\n\n---\n\n## Remote Tools\n\nThese tools run on Cloudflare Workers and require authentication via API key.\n\n### bind_resolve_issuer\n\nFetch an organization's public signing keys (JWKS) from the Bind Protocol API. Use this to inspect which keys an org has available for credential signing.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `orgId` | string | Yes | The organization ID to resolve (alphanumeric, hyphens, underscores) |\n\n**Returns:** JWKS JSON — `{ keys: [{ kty, crv, x, y, kid, ... }] }`.\n\n**Example prompt:**\n\n> \"What signing keys does the organization 'acme-corp' have?\"\n\n---\n\n### bind_explain_policy\n\nFetch and return the public specification for a Bind Protocol policy. Explains what claims the policy produces and what data sources it requires.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `policyId` | string | Yes | The policy ID to look up (alphanumeric, dots, hyphens, underscores) |\n\n**Returns:** Policy specification JSON including claims, data sources, and evaluation rules.\n\n**Example prompt:**\n\n> \"Explain what the policy bind.dimo.riskband.v0_1_0 does\"\n\n---\n\n### bind_check_revocation\n\nCheck the revocation status of a credential by its hash. Use `bind_hash_credential` on the local server to compute the hash first.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `credentialHash` | string | Yes | SHA-256 hash of the credential (hex string, optionally `0x`-prefixed) |\n\n**Returns:** Revocation status JSON.\n\n:::info\nThis tool takes a hash, not the raw credential. The hash is not reversible — the remote server never sees the credential contents.\n:::\n\n**Example prompt:**\n\n> \"Check if the credential with hash 0xabc123... has been revoked\"\n\n---\n\n### bind_list_policies\n\nList available Bind Protocol policies. Policies define what claims can be proved and what data sources are required.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `limit` | number | No | Maximum number of policies to return |\n| `offset` | number | No | Number of policies to skip for pagination |\n\n**Returns:** JSON array of policy objects.\n\n**Example prompt:**\n\n> \"What policies are available on Bind Protocol?\"\n\n---\n\n### bind_list_circuits\n\nList available Bind Protocol circuits. Circuits define the zero-knowledge proof logic used by policies.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `limit` | number | No | Maximum number of circuits to return |\n| `offset` | number | No | Number of circuits to skip for pagination |\n\n**Returns:** JSON array of circuit objects.\n\n**Example prompt:**\n\n> \"Show me the available circuits\"\n\n---\n\n### bind_submit_prove_job\n\nSubmit a new prove job to generate a zero-knowledge proof. Use `bind_list_policies` or `bind_list_circuits` to discover available circuits first. Poll the job status with `bind_get_prove_job`.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `circuitId` | string | Yes | The circuit ID to use for proof generation |\n| `inputs` | object | Yes | Key-value map of circuit inputs |\n| `verificationMode` | string | No | `zkverify` or `self_verify` (default: `zkverify`) |\n\n**Returns:** JSON object with the created job, including its `id` and initial `status`.\n\n**Example prompt:**\n\n> \"Submit a prove job using circuit credit-score-v1 with age=25\"\n\n---\n\n### bind_get_prove_job\n\nGet the status and result of a prove job by its ID. Poll this after submitting a prove job to check if the proof is ready.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `jobId` | string (UUID) | Yes | The prove job ID to look up |\n\n**Returns:** JSON object with job status, result, and metadata.\n\n**Example prompt:**\n\n> \"Check the status of prove job a1b2c3d4-e5f6-7890-abcd-ef1234567890\"\n\n---\n\n### bind_list_prove_jobs\n\nList prove jobs for the authenticated organization. Optionally filter by status.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `status` | string | No | Filter by status: `pending`, `processing`, `completed`, or `failed` |\n| `limit` | number | No | Maximum number of jobs to return |\n| `offset` | number | No | Number of jobs to skip for pagination |\n| `direction` | string | No | Sort direction: `asc` or `desc` (default: `desc`) |\n\n**Returns:** JSON array of prove job objects.\n\n**Example prompt:**\n\n> \"List my completed prove jobs\"\n\n---\n\n### bind_issue_credential\n\nIssue a verifiable credential from a completed prove job. The prove job must have status `completed` before a credential can be issued.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `proveJobId` | string (UUID) | Yes | The ID of the completed prove job |\n| `format` | string | No | `compact` or `self-verifiable` (default: `compact`) |\n| `subjectId` | string | No | DID or identifier of the credential subject |\n| `expiresIn` | number | No | Credential expiration in seconds from now |\n\n**Returns:** JSON object containing the issued verifiable credential.\n\n**Example prompt:**\n\n> \"Issue a credential from prove job a1b2c3d4-e5f6-7890-abcd-ef1234567890\"\n\n---\n\n### bind_share_proof\n\nShare a completed proof with a verifier organization. Creates a shared proof record that the verifier can access.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `proveJobId` | string (UUID) | Yes | The ID of the completed prove job to share |\n| `verifierOrgId` | string | Yes | The organization ID of the verifier |\n| `expiresAt` | string | No | ISO 8601 expiration timestamp |\n| `note` | string | No | Optional note to include with the shared proof |\n\n**Returns:** JSON object with the created shared proof record.\n\n**Example prompt:**\n\n> \"Share my proof a1b2c3d4-... with verifier org acme-corp\"\n\n---\n\n### bind_list_shared_proofs\n\nList shared proofs for the authenticated organization. Shows proofs that have been shared with or by the organization.\n\n**Parameters:**\n\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `limit` | number | No | Maximum number of shared proofs to return |\n| `offset` | number | No | Number of shared proofs to skip for pagination |\n| `direction` | string | No | Sort direction: `asc` or `desc` (default: `desc`) |\n\n**Returns:** JSON array of shared proof objects.\n\n**Example prompt:**\n\n> \"Show me all shared proofs\"\n\n## Next Steps\n\n- [Example Workflows](/mcp/workflows) — See these tools used together\n- [Credentials](/concepts/credentials) — How credentials work in Bind Protocol",
  },
  {
    uri: "bind://docs/mcp/workflows",
    title: "Example Workflows",
    content: "# Example Workflows\n\nCommon patterns for using Bind MCP tools together. These workflows span both the local and remote servers seamlessly — your AI agent handles the routing automatically.\n\n## Full Credential Verification\n\nThe most common workflow: take a VC-JWT and fully validate it.\n\n```mermaid\nflowchart LR\n    A[\"bind_parse_credential\\n(local)\"] --> B[\"bind_verify_credential\\n(local)\"]\n    B --> C[\"bind_hash_credential\\n(local)\"]\n    C --> D[\"bind_check_revocation\\n(remote)\"]\n```\n\n**Prompt:**\n\n> \"I have this credential: eyJhbGciOiJFUzI1NiIs... — please verify it completely, including revocation status.\"\n\n**What the agent does:**\n\n1. **Parse** — Decodes the JWT to inspect the header and claims\n2. **Verify** — Fetches the issuer's JWKS, verifies the signature, checks expiration\n3. **Hash** — Computes the SHA-256 hash\n4. **Check revocation** — Sends the hash (not the credential) to the remote server\n\n## Investigate an Issuer\n\nLook up an organization's signing keys and understand what policies they use.\n\n**Prompt:**\n\n> \"Tell me about the issuer 'acme-corp' — what keys do they have and what policies do they run?\"\n\n**What the agent does:**\n\n1. **Resolve issuer** — Fetches the JWKS for `acme-corp`\n2. **Explain policy** — Looks up each policy referenced in the org's credentials\n\n## Understand a Policy Before Verification\n\nWhen you receive a credential and want to understand what it proves before verifying.\n\n**Prompt:**\n\n> \"Parse this credential and explain what policy it was issued under: eyJhbGciOiJFUzI1NiIs...\"\n\n**What the agent does:**\n\n1. **Parse** — Extracts the header and payload\n2. **Explain policy** — Looks up the policy ID from the credential's claims\n\n## Batch Verification\n\nVerify multiple credentials and summarize the results.\n\n**Prompt:**\n\n> \"Verify all three of these credentials and give me a summary table:\n> 1. eyJhbGci...\n> 2. eyJhbGci...\n> 3. eyJhbGci...\"\n\nThe agent will run the full verification workflow for each credential in parallel and present a comparison.\n\n## Using Documentation Resources\n\nThe remote server exposes Bind Protocol documentation as MCP resources. Your agent can read these directly.\n\n**Prompt:**\n\n> \"Read the Bind Protocol docs about how credentials work, then verify this one: eyJhbGci...\"\n\nThe agent reads the `bind://docs/concepts/credentials` resource for context, then proceeds with verification.\n\n## Next Steps\n\n- [How Bind Works](/concepts/overview) — Understand the full attestation pipeline\n- [Credentials](/concepts/credentials) — Deep dive into credential structure\n- [API Reference](/api/overview) — Direct API access",
  },
  {
    uri: "bind://docs/quickstart",
    title: "Quickstart",
    content: "# Quickstart\n\nGet from zero to your first proof in 5 minutes.\n\n## 1. Get an API Key\n\nSign up at the [Bind Dashboard](https://dashboard.bindprotocol.xyz) and create an organization. Navigate to **Settings > API Keys** and create a new key.\n\nYour key will look like: `idbr_<keyId>_<secret>`\n\n## 2. Install the SDK\n\n```bash\nnpm install @bind-protocol/sdk\n```\n\n## 3. Browse Available Policies\n\nList public policies to find one that fits your use case:\n\n```typescript\nimport { BindClient } from '@bind-protocol/sdk';\n\nconst client = new BindClient({\n  apiKey: 'idbr_your_key_here',\n});\n\nconst policies = await client.listPolicies();\nfor (const policy of policies) {\n  console.log(`${policy.id}: ${policy.metadata.title}`);\n}\n```\n\nOr via the API directly:\n\n```bash\ncurl https://api.bindprotocol.com/api/policies\n```\n\n## 4. Submit a Prove Job\n\nOnce you have data and a policy, submit a prove job:\n\n```typescript\nconst { jobId } = await client.submitProveJob('bind.dimo.riskband.v0_1_0', {\n  mileage_90d: '2500',\n  data_points: '450',\n  speed_max: '72',\n});\n\nconsole.log(`Job submitted: ${jobId}`);\n```\n\n## 5. Wait for the Proof\n\nProofs are generated asynchronously. Poll for completion:\n\n```typescript\nconst job = await client.waitForProveJob(jobId, {\n  onProgress: (j) => console.log(`Status: ${j.status}`),\n});\n\nif (job.status === 'completed') {\n  console.log('Attestation ID:', job.attestationId);\n  console.log('zkVerify TX:', job.zkVerifyTxHash);\n}\n```\n\n## 6. Share or Verify\n\nOnce a proof is generated, you can:\n\n- **Share it** with a verifier organization via the shared proofs API\n- **Verify it** using the verification endpoints\n- **Download artifacts** for self-verification\n\n```bash\ncurl -X POST https://api.bindprotocol.com/api/shared-proofs \\\n  -H \"X-API-Key: idbr_your_key_here\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"proveJobId\": \"job_abc123\",\n    \"verifierOrgId\": \"org_verifier_id\"\n  }'\n```\n\n## What's Next?\n\n- [**Policies**](/concepts/policies) — Understand how policies work\n- [**Extractors**](/concepts/extractors) — Connect real data sources via zkTLS\n- [**Policy Authoring Guide**](/guides/policy-authoring) — Create your own policies\n- [**SDK Reference**](/sdk/bind-client) — Full SDK documentation",
  },
  {
    uri: "bind://docs/sdk/adapters",
    title: "Adapters",
    content: "# Adapters\n\nAdapters abstract data sources and transform their data into circuit inputs. They handle fetching data from external services and converting it into the format required by Bind policies.\n\n## DIMO Adapter\n\nFetches vehicle telemetry from the [DIMO Network](https://dimo.zone) and transforms it for risk band evaluation.\n\n### Setup\n\n```typescript\nimport { BindClient, DimoAdapter } from '@bind-protocol/sdk';\nimport { DIMO } from '@dimo-network/data-sdk';\n\n// Initialize DIMO client\nconst dimoClient = new DIMO('Production');\nawait dimoClient.auth.getToken({ /* ... */ });\n\n// Create adapter\nconst dimo = new DimoAdapter({ dimoClient });\n```\n\n### Fetch Data\n\n```typescript\nconst data = await dimo.fetchData({\n  vehicleTokenId: '12345',\n  from: '2024-01-01',\n  to: '2024-01-31',\n});\n```\n\n### Transform to Circuit Inputs\n\n```typescript\nconst inputs = dimo.toCircuitInputs(data, 'bind.dimo.riskband.v0_1_0');\n```\n\n### Submit Prove Job\n\n```typescript\nconst client = new BindClient({ apiKey: 'idbr_your_key' });\nconst { jobId } = await client.submitProveJob('bind.dimo.riskband.v0_1_0', inputs);\n```\n\n## Creating Custom Adapters\n\nImplement the `DataAdapter` interface for other data sources:\n\n```typescript\nimport type { DataAdapter, ProveJobInputs } from '@bind-protocol/sdk';\n\ninterface MyConfig {\n  apiUrl: string;\n}\n\ninterface MyQuery {\n  userId: string;\n  dateRange: { from: string; to: string };\n}\n\ninterface MyData {\n  metrics: number[];\n  timestamp: string;\n}\n\nclass MyAdapter implements DataAdapter<MyConfig, MyQuery, MyData> {\n  readonly id = 'my-adapter';\n  readonly name = 'My Data Source';\n  readonly description = 'Fetches data from my service';\n\n  constructor(private config: MyConfig) {}\n\n  async fetchData(query: MyQuery): Promise<MyData> {\n    const response = await fetch(\n      `${this.config.apiUrl}/users/${query.userId}/metrics`\n    );\n    return response.json();\n  }\n\n  toCircuitInputs(data: MyData, circuitId: string): ProveJobInputs {\n    return {\n      metrics: JSON.stringify(data.metrics),\n      timestamp: data.timestamp,\n    };\n  }\n}\n```\n\n### DataAdapter Interface\n\n```typescript\ninterface DataAdapter<TConfig, TQuery, TData> {\n  readonly id: string;\n  readonly name: string;\n  readonly description: string;\n\n  fetchData(query: TQuery): Promise<TData>;\n  toCircuitInputs(data: TData, circuitId: string): ProveJobInputs;\n}\n```",
  },
  {
    uri: "bind://docs/sdk/bind-client",
    title: "BindClient",
    content: "# BindClient\n\nThe core client for interacting with the Bind Protocol API.\n\n## Constructor\n\n```typescript\nimport { BindClient } from '@bind-protocol/sdk';\n\nconst client = new BindClient({\n  apiKey: 'idbr_your_key_here',\n});\n```\n\n## Methods\n\n### submitProveJob\n\nSubmit a prove job for async processing.\n\n```typescript\nconst { jobId } = await client.submitProveJob(circuitId, inputs);\n```\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `circuitId` | string | Policy/circuit identifier |\n| `inputs` | Record&lt;string, string&gt; | Circuit inputs |\n\nReturns: `{ jobId: string }`\n\n### getProveJob\n\nGet status and results of a prove job.\n\n```typescript\nconst job = await client.getProveJob(jobId);\n```\n\nReturns: `ProveJob`\n\n### listProveJobs\n\nList prove jobs with optional filters.\n\n```typescript\nconst { jobs, pagination } = await client.listProveJobs({\n  status: 'completed',\n  limit: 25,\n});\n```\n\n| Option | Type | Description |\n|--------|------|-------------|\n| `status` | string | Filter by status |\n| `limit` | number | Results per page (max 100) |\n| `offset` | number | Pagination offset |\n\n### waitForProveJob\n\nPoll until a job completes or fails.\n\n```typescript\nconst job = await client.waitForProveJob(jobId, {\n  pollInterval: 2000,    // ms between polls (default: 2000)\n  timeout: 120000,       // max wait time (default: 120000)\n  onProgress: (job) => console.log(job.status),\n});\n```\n\n| Option | Type | Description |\n|--------|------|-------------|\n| `pollInterval` | number | Milliseconds between polls |\n| `timeout` | number | Max wait time in ms |\n| `onProgress` | function | Called on each poll |\n\n### listPolicies\n\nList all public policies (no auth required).\n\n```typescript\nconst policies = await client.listPolicies();\n```\n\n### getPolicy\n\nGet a specific policy by ID.\n\n```typescript\nconst policy = await client.getPolicy('bind.mobility.basicriskband');\n```\n\n## Types\n\n```typescript\ninterface ProveJob {\n  jobId: string;\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  circuitId: string;\n  verificationMode: string;\n  createdAt: string;\n  startedAt: string | null;\n  completedAt: string | null;\n  error: string | null;\n  attestationId?: string;\n  zkVerifyTxHash?: string;\n}\n```",
  },
  {
    uri: "bind://docs/sdk/error-handling",
    title: "Error Handling",
    content: "# Error Handling\n\nThe SDK provides typed error classes for common failure scenarios.\n\n## Error Hierarchy\n\n```\nBindError (base)\n├── ApiError              # API returned an error response\n├── AuthenticationError   # Invalid or expired API key\n├── TimeoutError          # Operation exceeded time limit\n└── TierLimitExceededError  # Monthly usage limit reached\n```\n\n## Usage\n\n```typescript\nimport {\n  BindError,\n  ApiError,\n  AuthenticationError,\n  TimeoutError,\n  TierLimitExceededError,\n} from '@bind-protocol/sdk';\n\ntry {\n  await client.submitProveJob(circuitId, inputs);\n} catch (error) {\n  if (error instanceof TierLimitExceededError) {\n    console.log(`Monthly limit reached: ${error.message}`);\n  } else if (error instanceof AuthenticationError) {\n    console.log('Invalid API key');\n  } else if (error instanceof TimeoutError) {\n    console.log(`Timed out after ${error.timeoutMs}ms`);\n  } else if (error instanceof ApiError) {\n    console.log(`API error: ${error.message} (${error.statusCode})`);\n  }\n}\n```\n\n## Error Classes\n\n### BindError\n\nBase class for all SDK errors.\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `message` | string | Error description |\n\n### ApiError\n\nThrown when the API returns a non-2xx response.\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `statusCode` | number | HTTP status code |\n| `message` | string | Error message from API |\n\n### AuthenticationError\n\nThrown when the API key is invalid or expired.\n\n### TimeoutError\n\nThrown when `waitForProveJob` exceeds the timeout.\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `timeoutMs` | number | The timeout that was exceeded |\n\n### TierLimitExceededError\n\nThrown when the organization has reached its monthly operation limit.\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `message` | string | Description of the limit that was exceeded |",
  },
  {
    uri: "bind://docs/sdk/examples",
    title: "Examples",
    content: "# Examples\n\n## Insurance Risk Assessment (DIMO)\n\nEnd-to-end flow: fetch vehicle telemetry, generate a risk proof, and get a credential.\n\n```typescript\nimport { BindClient, DimoAdapter } from '@bind-protocol/sdk';\nimport { DIMO } from '@dimo-network/data-sdk';\n\nasync function generateRiskCredential(vehicleTokenId: string) {\n  // 1. Set up clients\n  const dimoClient = new DIMO('Production');\n  await dimoClient.auth.getToken({ /* your DIMO auth config */ });\n\n  const dimo = new DimoAdapter({ dimoClient });\n  const bind = new BindClient({ apiKey: process.env.BIND_API_KEY! });\n\n  // 2. Fetch 90 days of telemetry\n  const now = new Date();\n  const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);\n  const telemetry = await dimo.fetchData({\n    vehicleTokenId,\n    from: ninetyDaysAgo.toISOString(),\n    to: now.toISOString(),\n  });\n\n  // 3. Transform and submit prove job\n  const inputs = dimo.toCircuitInputs(telemetry, 'bind.dimo.riskband.v0_1_0');\n  const { jobId } = await bind.submitProveJob('bind.dimo.riskband.v0_1_0', inputs);\n\n  // 4. Wait for proof generation\n  const job = await bind.waitForProveJob(jobId, {\n    onProgress: (j) => console.log(`Status: ${j.status}`),\n  });\n\n  if (job.status !== 'completed') {\n    throw new Error(job.error || 'Proof generation failed');\n  }\n\n  // 5. Return credential reference\n  return {\n    policyId: 'bind.mobility.basicriskband',\n    attestationId: job.attestationId,\n    zkVerifyTxHash: job.zkVerifyTxHash,\n  };\n}\n```\n\n## Basic Prove Job\n\nSimplest possible integration — submit inputs and get a proof.\n\n```typescript\nimport { BindClient } from '@bind-protocol/sdk';\n\nconst client = new BindClient({ apiKey: process.env.BIND_API_KEY! });\n\n// Submit\nconst { jobId } = await client.submitProveJob('your-policy-id', {\n  field1: 'value1',\n  field2: 'value2',\n});\n\n// Wait\nconst job = await client.waitForProveJob(jobId);\nconsole.log(`Result: ${job.status}`);\n```\n\n## Listing and Selecting Policies\n\nBrowse available policies before submitting a prove job.\n\n```typescript\nimport { BindClient } from '@bind-protocol/sdk';\n\nconst client = new BindClient({ apiKey: process.env.BIND_API_KEY! });\n\n// List all public policies\nconst policies = await client.listPolicies();\n\nfor (const policy of policies) {\n  console.log(`${policy.id}: ${policy.metadata.title}`);\n  console.log(`  Outputs: ${policy.outputs.map(o => o.name).join(', ')}`);\n  console.log();\n}\n\n// Get details for a specific policy\nconst policy = await client.getPolicy('bind.mobility.basicriskband');\nconsole.log('Output types:', policy.outputs);\n```\n\n## Error Handling\n\nRobust error handling with typed errors.\n\n```typescript\nimport {\n  BindClient,\n  TierLimitExceededError,\n  AuthenticationError,\n  TimeoutError,\n} from '@bind-protocol/sdk';\n\nconst client = new BindClient({ apiKey: process.env.BIND_API_KEY! });\n\ntry {\n  const { jobId } = await client.submitProveJob(circuitId, inputs);\n  const job = await client.waitForProveJob(jobId, { timeout: 60000 });\n\n  if (job.status === 'completed') {\n    console.log('Success!', job.attestationId);\n  } else {\n    console.error('Job failed:', job.error);\n  }\n} catch (error) {\n  if (error instanceof TierLimitExceededError) {\n    console.error(`Monthly limit reached: ${error.message}`);\n    // Prompt user to upgrade tier\n  } else if (error instanceof AuthenticationError) {\n    console.error('Bad API key — check your configuration');\n  } else if (error instanceof TimeoutError) {\n    console.error('Proof generation is taking longer than expected');\n    // Could retry with longer timeout\n  } else {\n    throw error;\n  }\n}\n```\n\n## Custom Adapter\n\nBuild an adapter for your own data source.\n\n```typescript\nimport { BindClient } from '@bind-protocol/sdk';\nimport type { DataAdapter, ProveJobInputs } from '@bind-protocol/sdk';\n\n// Define your adapter\nclass CreditScoreAdapter implements DataAdapter<{apiKey: string}, {userId: string}, {score: number}> {\n  readonly id = 'credit-score';\n  readonly name = 'Credit Score Provider';\n  readonly description = 'Fetches credit scores for verification';\n\n  constructor(private config: { apiKey: string }) {}\n\n  async fetchData(query: { userId: string }) {\n    const res = await fetch(`https://api.creditprovider.com/scores/${query.userId}`, {\n      headers: { 'Authorization': `Bearer ${this.config.apiKey}` },\n    });\n    return res.json();\n  }\n\n  toCircuitInputs(data: { score: number }, circuitId: string): ProveJobInputs {\n    return {\n      creditScore: String(data.score),\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n\n// Use it\nconst adapter = new CreditScoreAdapter({ apiKey: 'provider-key' });\nconst data = await adapter.fetchData({ userId: 'user123' });\nconst inputs = adapter.toCircuitInputs(data, 'credit.score.verification.v1');\n\nconst client = new BindClient({ apiKey: process.env.BIND_API_KEY! });\nconst { jobId } = await client.submitProveJob('credit.score.verification.v1', inputs);\n```",
  },
  {
    uri: "bind://docs/sdk/installation",
    title: "Installation",
    content: "# Installation\n\n## npm\n\n```bash\nnpm install @bind-protocol/sdk\n```\n\n## pnpm\n\n```bash\npnpm add @bind-protocol/sdk\n```\n\n## yarn\n\n```bash\nyarn add @bind-protocol/sdk\n```\n\n## Configuration\n\n```typescript\nimport { BindClient } from '@bind-protocol/sdk';\n\nconst client = new BindClient({\n  apiKey: 'idbr_your_key_here',\n  baseUrl: 'https://api.bindprotocol.com', // optional, this is the default\n});\n```\n\n### Options\n\n| Option | Type | Required | Default | Description |\n|--------|------|----------|---------|-------------|\n| `apiKey` | string | Yes | — | Your Bind API key |\n| `baseUrl` | string | No | `https://api.bindprotocol.com` | API base URL |\n\n### Environment Variables\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `BIND_API_URL` | API base URL | `https://api.bindprotocol.com` |\n\n## Peer Dependencies\n\nFor the DIMO adapter, install the DIMO SDK separately:\n\n```bash\nnpm install @dimo-network/data-sdk\n```\n\nThis is an optional peer dependency — only required if you use the DIMO adapter.",
  },
  {
    uri: "bind://docs/sdk/overview",
    title: "SDK Overview",
    content: "# SDK Overview\n\nThe `@bind-protocol/sdk` is the official TypeScript SDK for integrating Bind Protocol into your applications.\n\n## Architecture\n\n```\n@bind-protocol/sdk\n├── core/           # Main client, types, and errors\n│   ├── BindClient  # API client for prove jobs and policies\n│   ├── types       # TypeScript type definitions\n│   └── errors      # Custom error classes\n└── adapters/       # Data source adapters\n    ├── dimo/       # DIMO Network integration\n    └── zktls/      # zkTLS attestation adapter\n```\n\n## Import Paths\n\n```typescript\n// Main entry point (recommended)\nimport { BindClient, DimoAdapter } from '@bind-protocol/sdk';\n\n// Or import specific modules\nimport { BindClient } from '@bind-protocol/sdk/core';\nimport { DimoAdapter } from '@bind-protocol/sdk/adapters/dimo';\n```\n\n## Requirements\n\n- Node.js >= 18.0.0\n- TypeScript >= 5.3 (for type definitions)\n\n## Quick Example\n\n```typescript\nimport { BindClient } from '@bind-protocol/sdk';\n\nconst client = new BindClient({\n  apiKey: 'idbr_your_key_here',\n});\n\n// Submit a prove job\nconst { jobId } = await client.submitProveJob('bind.dimo.riskband.v0_1_0', {\n  mileage_90d: '2500',\n  data_points: '450',\n  speed_max: '72',\n});\n\n// Wait for completion\nconst job = await client.waitForProveJob(jobId);\n\nif (job.status === 'completed') {\n  console.log('Proof generated:', job.attestationId);\n}\n```\n\n## Sections\n\n- [Installation](/sdk/installation) — Install and configure\n- [BindClient](/sdk/bind-client) — Core client reference\n- [Adapters](/sdk/adapters) — Data source adapters (DIMO, custom)\n- [Error Handling](/sdk/error-handling) — Typed errors and recovery\n- [Examples](/sdk/examples) — End-to-end integration examples",
  },
];
